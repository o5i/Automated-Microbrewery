<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
   <TITLE>Modbus Slave C++ Library: Examples</TITLE>
   <LINK href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
   <table width="100%"><tr>
   <td valign=bottom><b><font color=black size=4>
      FieldTalk<small><sup>&#153;</sup></small> Modbus<small><sup>&reg;</sup></small> Slave Library<br>
      C++ Editions</font></b></td>
   <td valign=bottom align=right>
      <a href="http://www.focus-sw.com">
      <img src="focuslogo50x200.png" border=0 size="50%"
       alt="FOCUS Software Engineering" ></a></td>
   </tr></table>
   <hr size=4 noshade color=gray>

<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="examples">Examples</a></h1><ul>
<li><a class="el" href="examples.html#example1">A Tiny Slave</a></li><li><a class="el" href="examples.html#example2">Shared Memory Data Provider example</a></li><li><a class="el" href="examples.html#example3">Diagnostic Slave</a></li></ul>
<h2><a class="anchor" name="example1">
A Tiny Slave</a></h2>
The following example tinyslave.cpp shows how to implement a small Modbus RTU slave:<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// Platform header</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="comment">// Include FieldTalk package header</span>
<span class="preprocessor">#include "MbusRtuSlaveProtocol.hpp"</span>


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Gobal data</span>
<span class="comment"> *****************************************************************************/</span>

<span class="preprocessor">#if defined(__LINUX__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/dev/ttyS0"</span>;
<span class="preprocessor">#elif defined(__WIN32__) || defined(__CYGWIN__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"COM1"</span>;
<span class="preprocessor">#elif defined(__FREEBSD__) || defined(__NETBSD__) || defined(__OPENBSD__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/dev/ttyd0"</span>;
<span class="preprocessor">#elif defined(__QNX__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/dev/ser1"</span>;
<span class="preprocessor">#elif defined(__VXWORKS__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/tyCo/0"</span>;
<span class="preprocessor">#elif defined(__IRIX__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/dev/ttyf1"</span>;
<span class="preprocessor">#elif defined(__SOLARIS__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/dev/ttya"</span>;
<span class="preprocessor">#elif defined(__OSF__)</span>
<span class="preprocessor"></span>   <span class="keywordtype">char</span> *portName = <span class="stringliteral">"/dev/tty00"</span>;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#  error Unknown platform, please add an entry for portName</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Modbus data table</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keyword">typedef</span> <span class="keyword">struct</span>
<span class="keyword"></span>{
   <span class="keywordtype">short</span> actTemp;           <span class="comment">// Register 1</span>
   <span class="keywordtype">short</span> minTemp;           <span class="comment">// Register 2</span>
   <span class="keywordtype">long</span>  scanCounter;       <span class="comment">// Register 3 and 4</span>
   <span class="keywordtype">float</span> setPoint;          <span class="comment">// Register 5 and 6</span>
   <span class="keywordtype">short</span> statusReg;         <span class="comment">// Register 7</span>
   <span class="keywordtype">short</span> configType;        <span class="comment">// Register 8</span>
} MyDeviceData;

MyDeviceData deviceData;


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Data provider</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keyword">class </span>MyDataProvider: <span class="keyword">public</span> <a class="code" href="classMbusDataTableInterface.html">MbusDataTableInterface</a>
{

  <span class="keyword">public</span>:

   <span class="keywordtype">int</span> readHoldingRegistersTable(<span class="keywordtype">int</span> startRef, <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(deviceData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(regArr, &amp;((<span class="keywordtype">short</span> *) &amp;deviceData)[startRef],
             refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                  <span class="keyword">const</span> <span class="keywordtype">short</span> regArr[],
                                  <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(deviceData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(&amp;((<span class="keywordtype">short</span> *) &amp;deviceData)[startRef],
             regArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }

} dataProvider;


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Modbus protocol declaration</span>
<span class="comment"> *****************************************************************************/</span>

<a class="code" href="classMbusRtuSlaveProtocol.html">MbusRtuSlaveProtocol</a> mbusServer;


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Function implementation</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keywordtype">void</span> startupServer()
{
   <span class="keywordtype">int</span> result;

   result = mbusServer.<a class="code" href="group__mbusslave.html#ga0">addDataTable</a>(1, &amp;dataProvider);
   <span class="keywordflow">if</span> (result == FTALK_SUCCESS)
      result = mbusServer.startupServer(portName,
                                        9600L, <span class="comment">// Baudrate</span>
                                        8,     <span class="comment">// Databits</span>
                                        1,     <span class="comment">// Stopbits</span>
                                        0);    <span class="comment">// Parity</span>
   if (result != FTALK_SUCCESS)
   {
      fprintf(stderr, <span class="stringliteral">"Error starting server: %s!\n"</span>,
              <a class="code" href="group__buserror.html#ga0">getBusProtocolErrorText</a>(result));
      exit(EXIT_FAILURE);
   }
}


<span class="keywordtype">void</span> shutdownServer()
{
   mbusServer.<a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolz27_4">shutdownServer</a>();
}


<span class="keywordtype">void</span> runServer()
{
   <span class="keywordtype">int</span> result = <a class="code" href="group__buserror.html#ga1">FTALK_SUCCESS</a>;

   <span class="keywordflow">while</span> (result == FTALK_SUCCESS)
   {
      result = mbusServer.<a class="code" href="classMbusRtuSlaveProtocol.html#MbusRtuSlaveProtocola4">serverLoop</a>();
      <span class="keywordflow">if</span> (result != FTALK_SUCCESS)
         fprintf(stderr, "%s!\n", getBusProtocolErrorText(result));
   }
}


<span class="keywordtype">int</span> main()
{
   atexit(shutdownServer);
   startupServer();
   runServer();
   <span class="keywordflow">return</span> (EXIT_FAILURE);
}
</pre></div><h2><a class="anchor" name="example2">
Shared Memory Data Provider example</a></h2>
The following example shows how to implement a Data Provider which serves it's data from shared memory:<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>ShmemMbusDataTable: <span class="keyword">public</span> <a class="code" href="classMbusDataTableInterface.html">MbusDataTableInterface</a>
{
  <span class="keyword">public</span>:

   ShmemMbusDataTable(<span class="keywordtype">int</span> table0Size, <span class="keywordtype">int</span> table1Size, <span class="keywordtype">int</span> table3Size, <span class="keywordtype">int</span> table4Size)
   {
      <span class="keywordtype">int</span> i;
      <span class="keywordtype">int</span> fd;

      <span class="keywordflow">for</span> (i = 0; i &lt; 5; i++)
      {
         <span class="comment">//</span>
         <span class="comment">// Determine table sizes</span>
         <span class="comment">//</span>
         <span class="keywordflow">switch</span> (i)
         {
           <span class="keywordflow">case</span> 0:
              <span class="keywordflow">if</span> (table0Size &lt;= 0)
                 break; <span class="comment">// No table will be created for this type</span>
              dataTableArr[i].size = table0Size * sizeof(<span class="keywordtype">char</span>);
           break;
           case 1:
              if (table1Size &lt;= 0)
                 break; <span class="comment">// No table will be created for this type</span>
              dataTableArr[i].size = table1Size * sizeof(<span class="keywordtype">char</span>);
           break;
           case 2:
              dataTableArr[i].size = sizeof(SlaveStatusInfo);
           break;
           case 3:
              if (table3Size &lt;= 0)
                 break; <span class="comment">// No table will be created for this type</span>
              dataTableArr[i].size = table3Size * sizeof(<span class="keywordtype">short</span>);
           break;
           case 4:
              if (table4Size &lt;= 0)
                 break; <span class="comment">// No table will be created for this type</span>
              dataTableArr[i].size = table4Size * sizeof(<span class="keywordtype">short</span>);
           break;
         }

         <span class="comment">//</span>
         <span class="comment">// Open shared memory tables</span>
         <span class="comment">//</span>
         shm_unlink(dataTableArr[i].name);
         if (dataTableArr[i].size == 0)
            continue;
         fd = shm_open(dataTableArr[i].name, O_CREAT | O_RDWR | O_EXCL, S_IRWXU);
         if (fd &lt; 0)
         {
            perror(<span class="stringliteral">"Shared memory open failed"</span>);
            abort();
         }
         
         <span class="comment">//</span>
         <span class="comment">// Size it</span>
         <span class="comment">//</span>
         <span class="keywordflow">if</span> (ftruncate(fd, dataTableArr[i].size) &lt; 0)
         {
            perror(<span class="stringliteral">"Shared memory ftruncate failed"</span>);
            abort();
         }
         
         <span class="comment">//</span>
         <span class="comment">// Map shared memory into address space</span>
         <span class="comment">//</span>
         dataTableArr[i].ptr = (<span class="keywordtype">short</span> *) mmap(0, dataTableArr[i].size, 
                                              PROT_READ | PROT_WRITE, 
                                              MAP_SHARED, fd, 0L);
         <span class="keywordflow">if</span> (dataTableArr[i].ptr == NULL)
         {
            perror(<span class="stringliteral">"Shared memory mmap failed"</span>);
            abort();
         }
         
         close  (fd);  <span class="comment">// No we can close the file descriptor</span>
         memset(dataTableArr[i].ptr, 0, dataTableArr[i].size);
      }

      <span class="comment">//</span>
      <span class="comment">// Handle special cases where we map table 3 to point to table 4 and</span>
      <span class="comment">// table 1 to point to table 0</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (table3Size == -1) <span class="comment">// Map table 3 to table 4</span>
      {
         dataTableArr[3].size = dataTableArr[4].size;
         dataTableArr[3].ptr = dataTableArr[4].ptr;
      }
      <span class="keywordflow">if</span> (table1Size == -1) <span class="comment">// Map table 1 to table 0</span>
      {
         dataTableArr[1].size = dataTableArr[0].size;
         dataTableArr[1].ptr = dataTableArr[0].ptr;
      }
      
      <span class="comment">// Setup pointer to status table</span>
      slaveStatusInfoPtr = (SlaveStatusInfo *) dataTableArr[2].ptr;

   }
   

   ~ShmemMbusDataTable()
   {
      <span class="keywordtype">int</span> i;

      <span class="keywordflow">for</span> (i = 0; i &lt; 5; i++)
      {
         <span class="keywordflow">if</span> (dataTableArr[i].ptr != NULL)
         {
            munmap(dataTableArr[i].ptr, dataTableArr[i].size);
            shm_unlink(dataTableArr[i].name);
         }
      }
   }
   

   <span class="keywordtype">void</span> timeOutHandler()
   {
      slaveStatusInfoPtr-&gt;timeoutCnt++;
   }


   <span class="keywordtype">int</span> readInputDiscretesTable(<span class="keywordtype">int</span> startRef,
                               <span class="keywordtype">char</span> bitArr[], 
                               <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\nreadInputDiscretesTable: %d, %d\n"</span>, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) (dataTableArr[1].size / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(bitArr, &amp;((<span class="keywordtype">char</span> *) dataTableArr[1].ptr)[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      slaveStatusInfoPtr-&gt;readDiscretesCnt++;
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readCoilsTable(<span class="keywordtype">int</span> startRef,
                      <span class="keywordtype">char</span> bitArr[], 
                      <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\nreadCoilsTable: %d, %d\n"</span>, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) (dataTableArr[0].size / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(bitArr, &amp;((<span class="keywordtype">char</span> *) dataTableArr[0].ptr)[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      slaveStatusInfoPtr-&gt;readDiscretesCnt++;
      <span class="keywordflow">return</span> (1);
   }

   
   <span class="keywordtype">int</span> writeCoilsTable(<span class="keywordtype">int</span> startRef,
                       <span class="keyword">const</span> <span class="keywordtype">char</span> bitArr[],
                       <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\nriteCoilsTable: %d, %d\n"</span>, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) (dataTableArr[0].size / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(&amp;((<span class="keywordtype">char</span> *) dataTableArr[0].ptr)[startRef], bitArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      slaveStatusInfoPtr-&gt;writeDiscretesCnt++;
      <span class="keywordflow">return</span> (1);
   }
   

   <span class="keywordtype">int</span> readInputRegistersTable(<span class="keywordtype">int</span> startRef,
                               <span class="keywordtype">short</span> regArr[],
                               <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\nreadInputRegistersTable: %d, %d\n"</span>, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) (dataTableArr[3].size / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(regArr, &amp;((<span class="keywordtype">short</span> *) dataTableArr[3].ptr)[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      slaveStatusInfoPtr-&gt;readRegistersCnt++;
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                 <span class="keywordtype">short</span> regArr[],
                                 <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\nreadHoldingRegistersTable: %d, %d\n"</span>, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) (dataTableArr[4].size / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(regArr, &amp;((<span class="keywordtype">short</span> *) dataTableArr[4].ptr)[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      slaveStatusInfoPtr-&gt;readRegistersCnt++;
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                  <span class="keyword">const</span> <span class="keywordtype">short</span> regArr[],
                                  <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\nwriteHoldingRegistersTable: %d, %d\n"</span>, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) (dataTableArr[4].size / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(&amp;((<span class="keywordtype">short</span> *) dataTableArr[4].ptr)[startRef], regArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      slaveStatusInfoPtr-&gt;writeRegistersCnt++;
      <span class="keywordflow">return</span> (1);
   }


  <span class="keyword">private</span>:

   SlaveStatusInfo *slaveStatusInfoPtr;

};
</pre></div><h2><a class="anchor" name="example3">
Diagnostic Slave</a></h2>
The following more complex example diagslave.cpp shows how to use the protocol stack in a context where the user can select the protocol type (TCP, RTU and ASCII) and other parameters. Diagslave is a slave simulator and test tool.<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// Platform header</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="comment">// Include FieldTalk package header</span>
<span class="preprocessor">#include "MbusRtuSlaveProtocol.hpp"</span>
<span class="preprocessor">#include "MbusAsciiSlaveProtocol.hpp"</span>
<span class="preprocessor">#include "MbusTcpSlaveProtocol.hpp"</span>
<span class="preprocessor">#include "DiagnosticDataTable.hpp"</span>

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">#  include "getopt.h"</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#  include &lt;unistd.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">/*****************************************************************************</span>
<span class="comment"> * String constants</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keyword">const</span> <span class="keywordtype">char</span> versionStr[]= <span class="stringliteral">"$Revision: 1.14 $"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> progName[] = <span class="stringliteral">"diagslave"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> bannerStr[] =
<span class="stringliteral">"\n"</span>
<span class="stringliteral">"%s - FieldTalk(tm) Modbus(R) Diagnostic Slave\n"</span>
<span class="stringliteral">"Copyright (c) 2002-2006 FOCUS Software Engineering Pty Ltd\n"</span>
<span class="stringliteral">"Visit http://www.modbusdriver.com for Modbus libraries and tools.\n"</span>
<span class="stringliteral">"\n"</span>;

<span class="keyword">const</span> <span class="keywordtype">char</span> usageStr[] =
<span class="stringliteral">"%s [options] [serialport]\n"</span>
<span class="stringliteral">"Arguments: \n"</span>
<span class="stringliteral">"serialport    Serial port when using Modbus ASCII or Modbus RTU protocol \n"</span>
<span class="stringliteral">"              COM1, COM2 ...                on Windows \n"</span>
<span class="stringliteral">"              /dev/ttyS0, /dev/ttyS1 ...    on Linux \n"</span>
<span class="stringliteral">"              /dev/ser1, /dev/ser2 ...      on QNX \n"</span>
<span class="stringliteral">"General options:\n"</span>
<span class="stringliteral">"-m ascii      Modbus ASCII protocol\n"</span>
<span class="stringliteral">"-m rtu        Modbus RTU protocol (default)\n"</span>
<span class="stringliteral">"-m tcp        MODBUS/TCP protocol\n"</span>
<span class="stringliteral">"-t #          Master poll time-out in ms (0-100000, 3000 is default)\n"</span>
<span class="stringliteral">"-a #          Slave address (1-255 for RTU/ASCII, 0-255 for TCP)\n"</span>
<span class="stringliteral">"Options for MODBUS/TCP:\n"</span>
<span class="stringliteral">"-p #          TCP port number (502 is default)\n"</span>
<span class="stringliteral">"Options for Modbus ASCII and Modbus RTU:\n"</span>
<span class="stringliteral">"-b #          Baudrate (e.g. 9600, 19200, ...) (9600 is default)\n"</span>
<span class="stringliteral">"-d #          Databits (7 or 8 for ASCII protocol, 8 for RTU)\n"</span>
<span class="stringliteral">"-s #          Stopbits (1 or 2, 1 is default)\n"</span>
<span class="stringliteral">"-p none       No parity\n"</span>
<span class="stringliteral">"-p even       Even parity (default)\n"</span>
<span class="stringliteral">"-p odd        Odd parity\n"</span>
<span class="stringliteral">""</span>;


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Enums</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keyword">enum</span>
{
   RTU,   
   ASCII, 
   TCP    
};


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Gobal configuration data</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keywordtype">int</span> address = -1;
<span class="keywordtype">long</span> timeout = 3000;
<span class="keywordtype">long</span> baudRate = 9600;
<span class="keywordtype">int</span> dataBits = 8;
<span class="keywordtype">int</span> stopBits = 1;
<span class="keywordtype">int</span> parity = <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw5">MbusSerialSlaveProtocol::SER_PARITY_EVEN</a>;
<span class="keywordtype">int</span> protocol = RTU;
<span class="keywordtype">char</span> *portName = NULL;
<span class="keywordtype">int</span> port = 502;


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Protocol and data table</span>
<span class="comment"> *****************************************************************************/</span>

DiagnosticMbusDataTable *dataTablePtrArr[256];
<a class="code" href="classMbusSlaveServer.html">MbusSlaveServer</a> *mbusServerPtr = NULL;


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * Function implementation</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keywordtype">void</span> printUsage()
{
   printf(<span class="stringliteral">"Usage: "</span>);
   printf(usageStr, progName);
   exit(EXIT_SUCCESS);
}


<span class="keywordtype">void</span> printVersion()
{
   printf(bannerStr, progName);
   printf(<span class="stringliteral">"Version: %s using FieldTalk package version %s\n"</span>,
          versionStr, MbusSlaveServer::getPackageVersion());
}


<span class="keywordtype">void</span> printConfig()
{
   printf(bannerStr, progName);
   printf(<span class="stringliteral">"Protocol configuration: "</span>);
   <span class="keywordflow">switch</span> (protocol)
   {
      <span class="keywordflow">case</span> RTU:
         printf(<span class="stringliteral">"Modbus RTU\n"</span>);
      <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> ASCII:
         printf(<span class="stringliteral">"Modbus ASCII\n"</span>);
      <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> TCP:
         printf(<span class="stringliteral">"MODBUS/TCP\n"</span>);
      <span class="keywordflow">break</span>;
      <span class="keywordflow">default</span>:
         printf(<span class="stringliteral">"unknown\n"</span>);
      <span class="keywordflow">break</span>;
   }
   printf(<span class="stringliteral">"Slave configuration: "</span>);
   printf(<span class="stringliteral">"Address = %d, "</span>, address);
   printf(<span class="stringliteral">"Master Time-out = %ld\n"</span>, timeout);
   <span class="keywordflow">if</span> (protocol == TCP)
   {
      printf(<span class="stringliteral">"TCP configuration: "</span>);
      printf(<span class="stringliteral">"Port = %d\n"</span>, port);
   }
   <span class="keywordflow">else</span>
   {
      printf(<span class="stringliteral">"Serial port configuration: "</span>);
      printf(<span class="stringliteral">"%s, "</span>, portName);
      printf(<span class="stringliteral">"%ld, "</span>, baudRate);
      printf(<span class="stringliteral">"%d, "</span>, dataBits);
      printf(<span class="stringliteral">"%d, "</span>, stopBits);
      <span class="keywordflow">switch</span> (parity)
      {
         <span class="keywordflow">case</span> <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw4">MbusSerialSlaveProtocol::SER_PARITY_NONE</a>:
            printf(<span class="stringliteral">"none\n"</span>);
         <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw5">MbusSerialSlaveProtocol::SER_PARITY_EVEN</a>:
            printf(<span class="stringliteral">"even\n"</span>);
         <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw6">MbusSerialSlaveProtocol::SER_PARITY_ODD</a>:
            printf(<span class="stringliteral">"odd\n"</span>);
         <span class="keywordflow">break</span>;
         <span class="keywordflow">default</span>:
            printf(<span class="stringliteral">"unknown\n"</span>);
         <span class="keywordflow">break</span>;
      }
   }
   printf(<span class="stringliteral">"\n"</span>);
}


<span class="keywordtype">void</span> exitBadOption(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> text)
{
   fprintf(stderr, <span class="stringliteral">"%s: %s! Try -h for help.\n"</span>, progName, text);
   exit(EXIT_FAILURE);
}


<span class="keywordtype">void</span> scanOptions(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
   <span class="keywordtype">int</span> c;

   <span class="comment">// Check for --version option</span>
   <span class="keywordflow">for</span> (c = 1; c &lt; argc; c++)
   {
      <span class="keywordflow">if</span> (strcmp (argv[c], <span class="stringliteral">"--version"</span>) == 0)
      {
         printVersion();
         exit(EXIT_SUCCESS);
      }
   }

   <span class="comment">// Check for --help option</span>
   <span class="keywordflow">for</span> (c = 1; c &lt; argc; c++)
   {
      <span class="keywordflow">if</span> (strcmp (argv[c], <span class="stringliteral">"--help"</span>) == 0)
         printUsage();
   }

   opterr = 0; <span class="comment">// Disable getopt's error messages</span>
   for(;;)
   {
      c = getopt(argc, argv, <span class="stringliteral">"ha:b:d:s:p:m:"</span>);
      <span class="keywordflow">if</span> (c == -1)
         break;

      switch (c)
      {
         <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:
            <span class="keywordflow">if</span> (strcmp(optarg, <span class="stringliteral">"tcp"</span>) == 0)
            {
               protocol = TCP;
            }
            <span class="keywordflow">else</span>
               <span class="keywordflow">if</span> (strcmp(optarg, <span class="stringliteral">"rtu"</span>) == 0)
               {
                  protocol = RTU;
               }
               <span class="keywordflow">else</span>
                  <span class="keywordflow">if</span> (strcmp(optarg, <span class="stringliteral">"ascii"</span>) == 0)
                  {
                     protocol = ASCII;
                  }
                  <span class="keywordflow">else</span>
                  {
                     exitBadOption(<span class="stringliteral">"Invalid protocol parameter"</span>);
                  }
         <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
            address = strtol(optarg, NULL, 0);
            <span class="keywordflow">if</span> ((address &lt; -1) || (address &gt; 255))
               exitBadOption("Invalid address parameter");
         break;
         case 't':
            timeout = strtol(optarg, NULL, 0);
            if ((timeout &lt; 0) || (timeout &gt; 100000))
               exitBadOption("Invalid time-out parameter");
         break;
         case 'b':
            baudRate = strtol(optarg, NULL, 0);
            if (baudRate == 0)
               exitBadOption("Invalid baudrate parameter");
         break;
         case 'd':
            dataBits = (<span class="keywordtype">int</span>) strtol(optarg, NULL, 0);
            if ((dataBits != 7) || (dataBits != 8))
               exitBadOption("Invalid databits parameter");
         break;
         case 's':
            stopBits = (<span class="keywordtype">int</span>) strtol(optarg, NULL, 0);
            if ((stopBits != 1) || (stopBits != 2))
               exitBadOption("Invalid stopbits parameter");
         break;
         case 'p':
            if (strcmp(optarg, "none") == 0)
            {
               parity = <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw4">MbusSerialSlaveProtocol::SER_PARITY_NONE</a>;
            }
            <span class="keywordflow">else</span>
               <span class="keywordflow">if</span> (strcmp(optarg, <span class="stringliteral">"odd"</span>) == 0)
               {
                  parity = <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw6">MbusSerialSlaveProtocol::SER_PARITY_ODD</a>;
               }
               <span class="keywordflow">else</span>
                  <span class="keywordflow">if</span> (strcmp(optarg, <span class="stringliteral">"even"</span>) == 0)
                  {
                     parity = <a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolw9MbusSerialSlaveProtocolw5">MbusSerialSlaveProtocol::SER_PARITY_EVEN</a>;
                  }
                  <span class="keywordflow">else</span>
                  {
                     port = strtol(optarg, NULL, 0);
                     <span class="keywordflow">if</span> ((port &lt;= 0) || (port &gt; 0xFFFF))
                        exitBadOption(<span class="stringliteral">"Invalid parity or port parameter"</span>);
                  }
         <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
            printUsage();
         <span class="keywordflow">break</span>;
         <span class="keywordflow">default</span>:
            exitBadOption(<span class="stringliteral">"Unrecognized option or missing option parameter"</span>);
         <span class="keywordflow">break</span>;
      }
   }

   <span class="keywordflow">if</span> (protocol == TCP)
   {
      <span class="keywordflow">if</span> ((argc - optind) != 0)
         exitBadOption("Invalid number of parameters");
   }
   else
   {
      <span class="keywordflow">if</span> ((argc - optind) != 1)
         exitBadOption("Invalid number of parameters");
      else
         portName = argv[optind];
   }
}




<span class="keywordtype">int</span> validateMasterIpAddr(<span class="keywordtype">char</span>* masterIpAddrSz)
{
   printf(<span class="stringliteral">"\nvalidateMasterIpAddr: accepting connection from %s\n"</span>,
          masterIpAddrSz);
   <span class="keywordflow">return</span> (1);
}


<span class="keywordtype">void</span> startupServer()
{
   <span class="keywordtype">int</span> i;
   <span class="keywordtype">int</span> result = -1;

   <span class="keywordflow">switch</span> (protocol)
   {
      <span class="keywordflow">case</span> RTU:
         mbusServerPtr = <span class="keyword">new</span> <a class="code" href="classMbusRtuSlaveProtocol.html">MbusRtuSlaveProtocol</a>();
         <span class="keywordflow">if</span> (address == -1)
         {
            <span class="keywordflow">for</span> (i = 1; i &lt; 255; i++)
            mbusServerPtr-&gt;addDataTable(i, dataTablePtrArr[i]);
         }
         else
            mbusServerPtr-&gt;addDataTable(address, dataTablePtrArr[address]);
         mbusServerPtr-&gt;setTimeout(timeout);
         result = ((<a class="code" href="classMbusRtuSlaveProtocol.html">MbusRtuSlaveProtocol</a> *) mbusServerPtr)-&gt;startupServer(
                    portName, baudRate, dataBits, stopBits, parity);
      break;
      case ASCII:
         mbusServerPtr = new <a class="code" href="classMbusAsciiSlaveProtocol.html">MbusAsciiSlaveProtocol</a>();
         if (address == -1)
         {
            <span class="keywordflow">for</span> (i = 1; i &lt; 255; i++)
            mbusServerPtr-&gt;addDataTable(i, dataTablePtrArr[i]);
         }
         else
            mbusServerPtr-&gt;addDataTable(address, dataTablePtrArr[address]);
         mbusServerPtr-&gt;setTimeout(timeout);
         result = ((MbusAsciiSlaveProtocol *) mbusServerPtr)-&gt;startupServer(
                   portName, baudRate, dataBits, stopBits, parity);
      break;
      case TCP:
         mbusServerPtr = new <a class="code" href="classMbusTcpSlaveProtocol.html">MbusTcpSlaveProtocol</a>();
         if (address == -1)
         {
            <span class="keywordflow">for</span> (i = 0; i &lt; 255; i++) <span class="comment">// Note: TCP support slave addres of 0</span>
               mbusServerPtr-&gt;addDataTable(i, dataTablePtrArr[i]);
         }
         else
            mbusServerPtr-&gt;addDataTable(address, dataTablePtrArr[address]);
         mbusServerPtr-&gt;setTimeout(timeout);
         ((MbusTcpSlaveProtocol *) mbusServerPtr)-&gt;installIpAddrValidationCallBack(validateMasterIpAddr);
         ((MbusTcpSlaveProtocol *) mbusServerPtr)-&gt;setPort((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port);
         result = ((MbusTcpSlaveProtocol *) mbusServerPtr)-&gt;startupServer();
      break;
   }
   switch (result)
   {
      <span class="keywordflow">case</span> <a class="code" href="group__buserror.html#ga1">FTALK_SUCCESS</a>:
         printf(<span class="stringliteral">"Server started up successfully.\n"</span>);
      <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> <a class="code" href="group__buserror.html#ga2">FTALK_ILLEGAL_ARGUMENT_ERROR</a>:
         fprintf(stderr, <span class="stringliteral">"Configuration setting not supported!\n"</span>);
         exit(EXIT_FAILURE);
      <span class="keywordflow">break</span>;
      <span class="keywordflow">default</span>:
         fprintf(stderr, <span class="stringliteral">"%s!\n"</span>, <a class="code" href="group__buserror.html#ga0">getBusProtocolErrorText</a>(result));
         exit(EXIT_FAILURE);
      <span class="keywordflow">break</span>;
   }
}


<span class="keywordtype">void</span> shutdownServer()
{
   printf(<span class="stringliteral">"Shutting down server.\n"</span>);
   <span class="keyword">delete</span> mbusServerPtr;
}


<span class="keywordtype">void</span> runServer()
{
   <span class="keywordtype">int</span> result = <a class="code" href="group__buserror.html#ga1">FTALK_SUCCESS</a>;

   printf(<span class="stringliteral">"Listening to network (Ctrl-C to stop)\n"</span>);
   <span class="keywordflow">while</span> (result == FTALK_SUCCESS)
   {
      result = mbusServerPtr-&gt;<a class="code" href="group__mbusslave.html#ga8">serverLoop</a>();
      <span class="keywordflow">if</span> (result != FTALK_SUCCESS)
         fprintf(stderr, "%s!\n", getBusProtocolErrorText(result));\
      else
      {
         printf(<span class="stringliteral">"."</span>);
         fflush(stdout);
      }
   }
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
   <span class="keywordtype">int</span> i;

   <span class="comment">// Construct data tables</span>
   <span class="keywordflow">for</span> (i = 0; i &lt; 255; i++)
   {
      dataTablePtrArr[i] = <span class="keyword">new</span> DiagnosticMbusDataTable(i);
   }

   scanOptions(argc, argv);
   printConfig();
   atexit(shutdownServer);
   startupServer();
   runServer();
   <span class="keywordflow">return</span> (EXIT_FAILURE);
}
</pre></div><p>
Diagslave uses the following diagnostic data table as Data Provider:<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#ifndef _DIAGNOSTICDATATABLE_H_INCLUDED</span>
<span class="preprocessor"></span><span class="preprocessor">#define _DIAGNOSTICDATATABLE_H_INCLUDED</span>
<span class="preprocessor"></span>

<span class="comment">// Platform header</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="comment">// Package header</span>
<span class="preprocessor">#include "MbusDataTableInterface.hpp"</span>


<span class="comment">/*****************************************************************************</span>
<span class="comment"> * DiagnosticMbusDataTable class declaration</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keyword">class </span>DiagnosticMbusDataTable: <span class="keyword">public</span> <a class="code" href="classMbusDataTableInterface.html">MbusDataTableInterface</a>
{

<span class="keyword">public</span>:

   DiagnosticMbusDataTable(<span class="keywordtype">int</span> slaveAddr)
   {
      this-&gt;slaveAddr = slaveAddr;
      memset(regData, 0, <span class="keyword">sizeof</span>(regData));
      memset(bitData, 0, <span class="keyword">sizeof</span>(bitData));
   }


   ~DiagnosticMbusDataTable()
   {
   }


   <span class="keywordtype">char</span> readExceptionStatus()
   {
      printf(<span class="stringliteral">"\rSlave %3d: readExceptionStatus\n"</span>, slaveAddr);
      <span class="keywordflow">return</span> (0x55);
   }


   <span class="keywordtype">int</span> readInputDiscretesTable(<span class="keywordtype">int</span> startRef,
                               <span class="keywordtype">char</span> bitArr[],
                               <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\rSlave %3d: readInputDiscretes from %d, %d references\n"</span>,
             slaveAddr, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(bitData) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(bitArr, &amp;bitData[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readCoilsTable(<span class="keywordtype">int</span> startRef,
                      <span class="keywordtype">char</span> bitArr[],
                      <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\rSlave %3d: readCoils from %d, %d references\n"</span>,
             slaveAddr, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(bitData) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(bitArr, &amp;bitData[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeCoilsTable(<span class="keywordtype">int</span> startRef,
                       <span class="keyword">const</span> <span class="keywordtype">char</span> bitArr[],
                       <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\rSlave %3d: writeCoils from %d, %d references\n"</span>,
             slaveAddr, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(bitData) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(&amp;bitData[startRef], bitArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readInputRegistersTable(<span class="keywordtype">int</span> startRef,
                               <span class="keywordtype">short</span> regArr[],
                               <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\rSlave %3d: readInputRegisters from %d, %d references\n"</span>,
             slaveAddr, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(regData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(regArr, &amp;regData[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                 <span class="keywordtype">short</span> regArr[],
                                 <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\rSlave %3d: readHoldingRegisters from %d, %d references\n"</span>,
             slaveAddr, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(regData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(regArr, &amp;regData[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                  <span class="keyword">const</span> <span class="keywordtype">short</span> regArr[],
                                  <span class="keywordtype">int</span> refCnt)
   {
      printf(<span class="stringliteral">"\rSlave %3d: writeHoldingRegisters from %d, %d references\n"</span>,
             slaveAddr, startRef, refCnt);

      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">//</span>
      <span class="comment">// Validate range</span>
      <span class="comment">//</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(regData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>)))
         <span class="keywordflow">return</span> (0);

      <span class="comment">//</span>
      <span class="comment">// Copy data</span>
      <span class="comment">//</span>
      memcpy(&amp;regData[startRef], regArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> validateMasterIpAddr(<span class="keywordtype">char</span>* masterIpAddrSz)
   {
      printf(<span class="stringliteral">"\nvalidateMasterIpAddr: accepting connection from %s\n"</span>,
             masterIpAddrSz);
      <span class="keywordflow">return</span> (1);
   }


  <span class="keyword">private</span>:

   <span class="keywordtype">int</span> slaveAddr;
   <span class="keywordtype">short</span> regData[0x10000];
   <span class="keywordtype">char</span> bitData[2000];

};


<span class="preprocessor">#endif // ifdef ..._H_INCLUDED</span>
</pre></div>    <hr>
   <table width="100%" cellspacing=0 cellpadding=5 border=0>
      <tr>
         <td class=footer valign=top>
         Copyright &copy; 2002-2006 <a href="http://www.focus-sw.com">
         FOCUS Software Engineering Pty Ltd</a>, Australia.
         All rights reserved.
         <br>
         Please see the <a href="notices.html">Notices</a> page for trademark notices.
         <br>
         Last updated: 20 Oct 2006
     </tr>
   </table>

</body>
</html>

