<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
   <TITLE>Modbus Slave C++ Library: Data Provider</TITLE>
   <LINK href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
   <table width="100%"><tr>
   <td valign=bottom><b><font color=black size=4>
      FieldTalk<small><sup>&#153;</sup></small> Modbus<small><sup>&reg;</sup></small> Slave Library<br>
      C++ Editions</font></b></td>
   <td valign=bottom align=right>
      <a href="http://www.focus-sw.com">
      <img src="focuslogo50x200.png" border=0 size="50%"
       alt="FOCUS Software Engineering" ></a></td>
   </tr></table>
   <hr size=4 noshade color=gray>

<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Data Provider</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
A Data Provider acts as an agent between your Application and the Server Engine. 
<p>
After instantiating a Server Engine class of any protocol flavour, you have to associate it with a Data Provider by calling addDataTable and passing a pointer to the Data Provider object.<p>
<div align="center">
<img src="mbusslave_collab.gif" alt="mbusslave_collab.gif">
</div>
 <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classMbusRtuSlaveProtocol.html">MbusRtuSlaveProtocol</a> mbusProtocol;
 mbusProtocol.<a class="code" href="group__mbusslave.html#ga0">addDataTable</a>(1, &amp;dataTable);
</pre></div><p>
To create an application specific Data Provider derive a new class from <a class="el" href="classMbusDataTableInterface.html">MbusDataTableInterface</a> and override the required data access methods.<p>
A minimal Data Provider which realises a Modbus slave with read access to holding registers would be: <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyDataProvider: <span class="keyword">public</span> <a class="code" href="classMbusDataTableInterface.html">MbusDataTableInterface</a>
{
  <span class="keyword">public</span>:

   MyDataProvider() {}

   <span class="comment">// Override readHoldingRegistersTable method:</span>
   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga0">readHoldingRegistersTable</a>(<span class="keywordtype">int</span> startRef, <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      ... your application specific implementation
   }
};
</pre></div> 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusDataTableInterface.html">MbusDataTableInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class defines the interface between a Modbus slave Server Engine and your application. Descendants of this class are referred to as Data Providers.  <a href="classMbusDataTableInterface.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Data Access Methods for Table 4:00000 (Holding Registers)</h2></td></tr>
<tr><td colspan="2">Data Access Methods to support read and write of output registers (holding registers) in table 4:00000.<p>
This table is accessed by the following Modbus functions:<p>
<ul>
<li>Modbus function 16 (10 hex), Preset Multiple Registers/Write Multiple Registers</li><li>Modbus function 3 (03 hex), Read Holding Registers/Read Multiple Registers</li><li>Modbus function 6 (06 hex), Preset Single Register/Write Single Register.</li><li>Modbus function 22 (16 hex), Mask Write Register.</li><li>Modbus function 23 (17 hex), Read/Write Registers. </li></ul>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga0">MbusDataTableInterface::readHoldingRegistersTable</a> (int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a Data Provider function to read Holding Registers.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga6">MbusDataTableInterface::writeHoldingRegistersTable</a> (int startRef, const short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a Data Provider function to write Holding Registers.  <a href="#ga6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data Access Methods for Table 3:00000 (Input Registers)</h2></td></tr>
<tr><td colspan="2">Data Access Methods to support read of input registers in table 3:00000.<p>
This table is accessed by the following Modbus functions:<p>
<ul>
<li>Modbus function 4 (04 hex), Read Input Registers.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Input registers cannot be written </dd></dl>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga1">MbusDataTableInterface::readInputRegistersTable</a> (int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a Data Provider function to read Input Registers.  <a href="#ga1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data Access Methods for Table 0:00000 (Coils)</h2></td></tr>
<tr><td colspan="2">Data Access Methods to support read and write of discrete outputs (coils) in table 0:00000.<p>
This table is accessed by the following Modbus functions:<p>
<ul>
<li>Modbus function 1 (01 hex), Read Coil Status/Read Coils.</li><li>Modbus function 5 (05 hex), Force Single Coil/Write Coil.</li><li>Modbus function 15 (0F hex), Force Multiple Coils. </li></ul>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga2">MbusDataTableInterface::readCoilsTable</a> (int startRef, char bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a Data Provider function to read Coils.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga7">MbusDataTableInterface::writeCoilsTable</a> (int startRef, const char bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a Data Provider function to write Coils.  <a href="#ga7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data Access Methods for Table 1:00000 (Input Discretes)</h2></td></tr>
<tr><td colspan="2">Data Access Methods to support read discrete inputs (input status) in table 1:00000.<p>
This table is accessed by the following Modbus functions:<p>
<ul>
<li>Modbus function 2 (02 hex), Read Inputs Status/Read Input Discretes.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Input Discretes cannot be written </dd></dl>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga3">MbusDataTableInterface::readInputDiscretesTable</a> (int startRef, char bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a Data Provider function to read Coils.  <a href="#ga3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data Access Synchronisation Functions</h2></td></tr>
<tr><td colspan="2">Implementation of these functions may only be required in multithreaded applications, if you are running the server loop in a separate thread and in addition require data consistency over a block of Modbus registers.<p>
Data consistency within a single register is always maintained if the code executes on a 16-bit or 32-bit machine, because the CPU is accessing these data types atomically. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga4">MbusDataTableInterface::lock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">You can override this method to implement a semaphore locking mechanism to synchronise data access.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga8">MbusDataTableInterface::unlock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">You can override this method to implement a semaphore un-locking mechanism to synchronise data access.  <a href="#ga8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Auxiliary Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga5">MbusDataTableInterface::timeOutHandler</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a function to handle master poll time-outs.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataprovider.html#ga9">MbusDataTableInterface::readExceptionStatus</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to implement a function with reports the eight exception status coils (bits) within the slave device.  <a href="#ga9"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga0" doxytag="MbusDataTableInterface::readHoldingRegistersTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int readHoldingRegistersTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>short&nbsp;</td>
          <td class="mdname" nowrap> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a Data Provider function to read Holding Registers. 
<p>
When a slave receives a poll request for the 4:00000 data table he calls this method to retrieve the data.<p>
A simple implementation which holds the application data in an array of shorts (<code>short regData[0x10000]</code>) could be: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga0">readHoldingRegistersTable</a>(<span class="keywordtype">int</span> startRef, <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      startRef--; <span class="comment">// Adjust Modbus reference counting</span>

      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(regData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))
         <span class="keywordflow">return</span> (0);

      memcpy(regArr, &amp;regData[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 0x10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regArr</em>&nbsp;</td><td>Buffer which has to be filled with the reply data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of registers to be retrieved (Range: 0 - 125)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicate a successful access and that valid reply data is contained in regArr. The Server Engine will reply the data passed in regArr to the master. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Indicate that access has been denied or is out of range. The Server Engine will reply to the master with an exception reply message</td></tr>
  </table>
</dl>
<dl compact><dt><b>Required:</b></dt><dd>Yes </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 which indicates to Server Engine that this address range is unsupported. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="MbusDataTableInterface::readInputRegistersTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int readInputRegistersTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>short&nbsp;</td>
          <td class="mdname" nowrap> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a Data Provider function to read Input Registers. 
<p>
When a slave receives a poll request for the 3:00000 data table he calls this method to retrieve the data.<p>
A simple and very common implementation is to map the Input Registers to the same address space than the Holding Registers table: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga1">readInputRegistersTable</a>(<span class="keywordtype">int</span> startRef, <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      <span class="keywordflow">return</span> (<a class="code" href="group__dataprovider.html#ga0">readHoldingRegistersTable</a>(startRef, regArr, refCnt);
   }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 0x10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regArr</em>&nbsp;</td><td>Buffer which has to be filled with the reply data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of registers to be retrieved (Range: 0 - 125)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicate a successful access and that valid reply data is contained in regArr. The Server Engine will reply the data passed in regArr to the master. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Indicate that access has been denied or is out of range. The Server Engine will reply to the master with an exception reply message</td></tr>
  </table>
</dl>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 which indicates to Server Engine that this address range is unsupported. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="MbusDataTableInterface::readCoilsTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int readCoilsTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a Data Provider function to read Coils. 
<p>
When a slave receives a poll request for the 0:00000 data table he calls this method to retrieve the data.<p>
A simple implementation which holds the boolean application data in an array of chars (<code>char bitData[2000]</code>) could be: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga2">readCoilsTable</a>(<span class="keywordtype">int</span> startRef, <span class="keywordtype">char</span> bitArr[], <span class="keywordtype">int</span> refCnt)
   {
      startRef--; <span class="comment">// Adjust Modbus reference counting</span>

      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(bitData) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
         <span class="keywordflow">return</span> (0);

      memcpy(bitArr, &amp;bitData[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 0x10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitArr</em>&nbsp;</td><td>Buffer which has to be filled with the reply data. Each char represents one coil! </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of coils to be retrieved (Range: 0 - 2000)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicate a successful access and that valid reply data is contained in regArr. The Server Engine will reply the data passed in regArr to the master. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Indicate that access has been denied or is out of range. The Server Engine will reply to the master with an exception reply message</td></tr>
  </table>
</dl>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 which indicates to Server Engine that this address range is unsupported. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="MbusDataTableInterface::readInputDiscretesTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int readInputDiscretesTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a Data Provider function to read Coils. 
<p>
When a slave receives a poll request for the 0:00000 data table he calls this method to retrieve the data.<p>
A simple and very common implementation is to map the Input Discretes to the same address space than the Coils table: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga3">readInputDiscretesTable</a>(<span class="keywordtype">int</span> startRef, <span class="keywordtype">char</span> bitArr[], <span class="keywordtype">int</span> refCnt)
   {
      <span class="keywordflow">return</span> (<a class="code" href="group__dataprovider.html#ga2">readCoilsTable</a>(startRef, bitArr, refCnt));
   }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 0x10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitArr</em>&nbsp;</td><td>Buffer which has to be filled with the reply data. Each char repesents one discrete! </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of discretes to be retrieved (Range: 0 - 2000)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicate a successful access and that valid reply data is contained in regArr. The Server Engine will reply the data passed in regArr to the master. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Indicate that access has been denied or is out of range. The Server Engine will reply to the master with an exception reply message</td></tr>
  </table>
</dl>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 which indicates to Server Engine that this address range is unsupported. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="MbusDataTableInterface::lock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
You can override this method to implement a semaphore locking mechanism to synchronise data access. 
<p>
This is not needed in single threaded applications but may be necessary in multithreaded applications if you are running the server loop in a separate thread and require data consistency over a block of Modbus registers. Data consistency within a single register is always maintained if the code executes on a 16-bit or 32-bit machine, because the CPU is accessing these data types atomically.<p>
This function is called by the server before calling any data read or write functions.<p>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Empty </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="MbusDataTableInterface::timeOutHandler"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void timeOutHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a function to handle master poll time-outs. 
<p>
A master should poll a slave cyclically. If no master is polling within the time-out period this method is called. A slave can take certain actions if the master has lost connection, e.g. go into a fail-safe state.<p>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Empty </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="MbusDataTableInterface::writeHoldingRegistersTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int writeHoldingRegistersTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const short&nbsp;</td>
          <td class="mdname" nowrap> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a Data Provider function to write Holding Registers. 
<p>
When a slave receives a write request for the 4:00000 data table he calls this method to pass the data to the application.<p>
A simple implementation which holds the application data in an array of shorts (<code>short regData[0x10000]</code>) could be: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga6">writeHoldingRegistersTable</a>(<span class="keywordtype">int</span> startRef, <span class="keyword">const</span> <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      startRef--; <span class="comment">// Adjust Modbus reference counting</span>

      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(regData) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))
         <span class="keywordflow">return</span> (0);

      memcpy(&amp;regData[startRef], regArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 0x10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regArr</em>&nbsp;</td><td>Buffer which contains the received data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of registers received (Range: 0 - 125)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicate a successful access. The Server Engine will send a positive reply to the master. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Indicate that access has been denied or is out of range. The Server Engine will reply to the master with an exception reply message</td></tr>
  </table>
</dl>
<dl compact><dt><b>Required:</b></dt><dd>Yes </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 which indicates to Server Engine that this address range is unsupported. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="MbusDataTableInterface::writeCoilsTable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual int writeCoilsTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char&nbsp;</td>
          <td class="mdname" nowrap> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a Data Provider function to write Coils. 
<p>
When a slave receives a write request for the 0:00000 data table he calls this method to pass the data to the application.<p>
A simple implementation which holds the boolean application data in an array of chars (<code>char bitData[2000]</code>) could be: <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> <a class="code" href="group__dataprovider.html#ga7">writeCoilsTable</a>(<span class="keywordtype">int</span> startRef, <span class="keyword">const</span> <span class="keywordtype">char</span> bitArr[], <span class="keywordtype">int</span> refCnt)
   {
      startRef--; <span class="comment">// Adjust Modbus reference counting</span>

      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(bitData) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
         <span class="keywordflow">return</span> (0);

      memcpy(&amp;bitData[startRef], bitArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 0x10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitArr</em>&nbsp;</td><td>Buffer which contains the received data. Each char repesents one coil! </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of coils received (Range: 0 - 2000)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicate a successful access. The Server Engine will send a positive reply to the master. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Indicate that access has been denied or is out of range. The Server Engine will reply to the master with an exception reply message</td></tr>
  </table>
</dl>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 which indicates to Server Engine that this address range is unsupported. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="MbusDataTableInterface::unlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
You can override this method to implement a semaphore un-locking mechanism to synchronise data access. 
<p>
This is not needed in single threaded applications but may be necessary in multithreaded applications if you are running the server loop in a separate thread and require data consistency over a block of Modbus registers. Data consistency within a single register is always maintained if the code executes on a 16-bit or 32-bit machine, because the CPU is accessing these data types atomically.<p>
This function is called by the server after calling any data read or write functions.<p>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Empty </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="MbusDataTableInterface::readExceptionStatus"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual char readExceptionStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Override this method to implement a function with reports the eight exception status coils (bits) within the slave device. 
<p>
The exception status coils are device specific and usually used to report a device' principal status or a device' major failure codes as a 8-bit word.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Exception status byte</dd></dl>
<dl compact><dt><b>Required:</b></dt><dd>No </dd></dl>
<dl compact><dt><b>Default Implementation:</b></dt><dd>Returns 0 as exception status byte. </dd></dl>
    </td>
  </tr>
</table>
   <hr>
   <table width="100%" cellspacing=0 cellpadding=5 border=0>
      <tr>
         <td class=footer valign=top>
         Copyright &copy; 2002-2006 <a href="http://www.focus-sw.com">
         FOCUS Software Engineering Pty Ltd</a>, Australia.
         All rights reserved.
         <br>
         Please see the <a href="notices.html">Notices</a> page for trademark notices.
         <br>
         Last updated: 20 Oct 2006
     </tr>
   </table>

</body>
</html>

