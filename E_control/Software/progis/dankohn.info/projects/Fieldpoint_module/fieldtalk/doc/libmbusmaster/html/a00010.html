<!-- <?php echo "--".">";
include_once $_SERVER['DOCUMENT_ROOT'] . '/include/prepend.inc';
siteHeader("Modbus Master Protocol Library / C++ Editions - MbusRtuMasterProtocol class Reference",
           // Description:
           "Modbus RTU, Modbus ASCII, MODBUS/TCP Master C++ library and driver Documentation",
           // Keywords:
           $keywords);
echo "<"."!--"; if (false) { ?> -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
   <TITLE>FieldTalk Modbus Master Protocol Library / C++ Editions - MbusRtuMasterProtocol class Reference</TITLE>
   <LINK href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
   <table width="100%"><tr>
   <td valign=bottom><b><font color=black size=4>
      FieldTalk<small><sup>&#153;</sup></small> Modbus<small><sup>&reg;</sup></small> Master Protocol Library<br>
      C++ Editions</font></b></td>
   <td valign=bottom align=right>
      <a href="http://www.focus-sw.com">
      <img src="focuslogo50x200.png" border=0 size="50%"
       alt="FOCUS Software Engineering" ></a></td>
   </tr></table>
   <hr size=4 noshade color=gray>
<!-- <?php } echo "--".">"; echo "<"."!--"; ?> -->

<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>MbusRtuMasterProtocol Class Reference<br>
<small>
[<a class="el" href="a00039.html">Serial Protocols</a>]</small>
</h1>Inheritance diagram for MbusRtuMasterProtocol:<p><center><img src="a00048.gif" border="0" usemap="#a00049" alt="Inheritance graph"></center>
<map name="a00049">
<area href="a00012.html" shape="rect" coords="7,432,188,592" alt="">
<area href="a00009.html" shape="rect" coords="16,16,179,384" alt="">
</map>
Collaboration diagram for MbusRtuMasterProtocol:<p><center><img src="a00050.gif" border="0" usemap="#a00051" alt="Collaboration graph"></center>
<map name="a00051">
<area href="a00012.html" shape="rect" coords="7,432,188,592" alt="">
<area href="a00009.html" shape="rect" coords="16,16,179,384" alt="">
</map>
<a href="a00005.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Modbus RTU Master Protocol class. 
<p>
This class realizes the Modbus RTU master protocol. It provides functions to open and to close serial port as well as data and control functions which can be used at any time after the protocol has been opened. The data and control functions are organized different conformance classes. For a more detailed description of the data and control functions see section <a class="el" href="a00036.html">Data and Control Functions for all Protocol Flavours</a>.<p>
It is possible to instantiate multiple instances of this class for establishing multiple connections on different serial ports (They should be executed in separate threads).<p>
<dl compact><dt><b>Version:</b></dt><dd>1.1 </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="a00036.html">mbusmaster</a> <p>
<a class="el" href="a00012.html">MbusSerialMasterProtocol</a>, <a class="el" href="a00009.html">MbusMasterFunctions</a> </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Specialised Serial Port Management Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00010.html#MbusRtuMasterProtocolz3_0">openProtocol</a> (const char *const portName, long baudRate, int dataBits, int stopBits, int parity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a Modbus RTU protocol and the associated serial port with specific port parameters. </em> <a href="#MbusRtuMasterProtocolz3_0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00010.html#MbusRtuMasterProtocolz3_1">openProtocol</a> (const char *const portName, long baudRate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a Modbus RTU protocol and the associated serial port with default port parameters. </em> <a href="#MbusRtuMasterProtocolz3_1"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Serial Port Management Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="MbusSerialMasterProtocolz25_2" doxytag="MbusRtuMasterProtocol::closeProtocol"></a>
virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00010.html#MbusSerialMasterProtocolz25_2">closeProtocol</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the serial port and releases any system resources associated with the port. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00010.html#MbusSerialMasterProtocolz25_3">isOpen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the protocol is open or not. </em> <a href="#MbusSerialMasterProtocolz25_3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00010.html#MbusSerialMasterProtocolz25_4">enableRs485Mode</a> (int rtsDelay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables RS485 mode. </em> <a href="#MbusSerialMasterProtocolz25_4"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 0 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a0">writeMultipleRegisters</a> (int slaveAddr, int startRef, const short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex), Preset Multiple Registers/Write Multiple Registers. </em> <a href="a00036.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a7">writeMultipleLongInts</a> (int slaveAddr, int startRef, const long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. </em> <a href="a00036.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a8">writeMultipleMod10000</a> (int slaveAddr, int startRef, const long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. </em> <a href="a00036.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a9">writeMultipleFloats</a> (int slaveAddr, int startRef, const float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. </em> <a href="a00036.html#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a10">readMultipleRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex), Read Holding Registers/Read Multiple Registers. </em> <a href="a00036.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a11">readMultipleLongInts</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. </em> <a href="a00036.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a12">readMultipleMod10000</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. </em> <a href="a00036.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a13">readMultipleFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. </em> <a href="a00036.html#a13"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 1 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a1">readCoils</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 1 (01 hex), Read Coil Status/Read Coils. </em> <a href="a00036.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a14">readInputDiscretes</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 2 (02 hex), Read Inputs Status/Read Input Discretes. </em> <a href="a00036.html#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a15">readInputRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex), Read Input Registers. </em> <a href="a00036.html#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a16">readInputLongInts</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit long int data types, Read Input Registers as long int data. </em> <a href="a00036.html#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a17">readInputMod10000</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. </em> <a href="a00036.html#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a18">readInputFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit float data types, Read Input Registers as float data. </em> <a href="a00036.html#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a19">writeCoil</a> (int slaveAddr, int bitAddr, int bitVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 5 (05 hex), Force Single Coil/Write Coil. </em> <a href="a00036.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a20">writeSingleRegister</a> (int slaveAddr, int regAddr, short regVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 6 (06 hex), Preset Single Register/Write Single Register. </em> <a href="a00036.html#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a21">readExceptionStatus</a> (int slaveAddr, unsigned char *statusByte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 7 (07 hex), Read Exception Status. </em> <a href="a00036.html#a21"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 2 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a2">forceMultipleCoils</a> (int slaveAddr, int startRef, const int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 15 (0F hex), Force Multiple Coils. </em> <a href="a00036.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a22">maskWriteRegister</a> (int slaveAddr, int regAddr, unsigned short andMask, unsigned short orMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 22 (16 hex), Mask Write Register. </em> <a href="a00036.html#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a23">readWriteRegisters</a> (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 23 (17 hex), Read/Write Registers. </em> <a href="a00036.html#a23"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Protocol Configuration</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a3">setTimeout</a> (int timeOut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures time-out. </em> <a href="a00036.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a24">getTimeout</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the time-out value. </em> <a href="a00036.html#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a25">setPollDelay</a> (int pollDelay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures poll delay. </em> <a href="a00036.html#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a26">getPollDelay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the poll delay time. </em> <a href="a00036.html#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a27">setRetryCnt</a> (int retryCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the automatic retry setting. </em> <a href="a00036.html#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a28">getRetryCnt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the automatic retry count. </em> <a href="a00036.html#a28"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Transmission Statistic Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a4">getTotalCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer has been executed. </em> <a href="a00036.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="MbusRtuMasterProtocol::resetTotalCounter"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a29">resetTotalCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets total message transfer counter. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a30">getSuccessCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer was successful. </em> <a href="a00036.html#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a31" doxytag="MbusRtuMasterProtocol::resetSuccessCounter"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a31">resetSuccessCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets successful message transfer counter. <br><br></td></tr>
<tr><td colspan=2><br><h2>Word Order Configuration</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a5">configureBigEndianInts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures int data type functions to do a word swap. </em> <a href="a00036.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a32">configureSwappedFloats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions to do a word swap. </em> <a href="a00036.html#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a33">configureLittleEndianInts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures int data type functions not to do a word swap. </em> <a href="a00036.html#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a34">configureIeeeFloats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions not to do a word swap. </em> <a href="a00036.html#a34"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom>{ <a class="el" href="a00010.html#MbusSerialMasterProtocolw7MbusSerialMasterProtocolw0">SER_DATABITS_7</a> =  SerialPort::SER_DATABITS_7, 
<a class="el" href="a00010.html#MbusSerialMasterProtocolw7MbusSerialMasterProtocolw1">SER_DATABITS_8</a> =  SerialPort::SER_DATABITS_8
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom>{ <a class="el" href="a00010.html#MbusSerialMasterProtocolw8MbusSerialMasterProtocolw2">SER_STOPBITS_1</a> =  SerialPort::SER_STOPBITS_1, 
<a class="el" href="a00010.html#MbusSerialMasterProtocolw8MbusSerialMasterProtocolw3">SER_STOPBITS_2</a> =  SerialPort::SER_STOPBITS_2
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom>{ <a class="el" href="a00010.html#MbusSerialMasterProtocolw9MbusSerialMasterProtocolw4">SER_PARITY_NONE</a> =  SerialPort::SER_PARITY_NONE, 
<a class="el" href="a00010.html#MbusSerialMasterProtocolw9MbusSerialMasterProtocolw5">SER_PARITY_EVEN</a> =  SerialPort::SER_PARITY_EVEN, 
<a class="el" href="a00010.html#MbusSerialMasterProtocolw9MbusSerialMasterProtocolw6">SER_PARITY_ODD</a> =  SerialPort::SER_PARITY_ODD
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="MbusRtuMasterProtocola0" doxytag="MbusRtuMasterProtocol::MbusRtuMasterProtocol"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00010.html#MbusRtuMasterProtocola0">MbusRtuMasterProtocol</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a MbusRtuMasterProtocol object and initialises its data. <br><br></td></tr>
<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a6">getPackageVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the package version number. </em> <a href="a00036.html#a6"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom>{ <a class="el" href="a00010.html#MbusSerialMasterProtocolx2MbusSerialMasterProtocolx0">SER_RS232</a>, 
<a class="el" href="a00010.html#MbusSerialMasterProtocolx2MbusSerialMasterProtocolx1">SER_RS485</a>
 }</td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a name="MbusSerialMasterProtocolw7" doxytag="MbusRtuMasterProtocol::@2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> anonymous enum<code> [inherited]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw7MbusSerialMasterProtocolw0" doxytag="SER_DATABITS_7"></a><em>SER_DATABITS_7</em></em>&nbsp;</td><td>
7 data bits </td></tr>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw7MbusSerialMasterProtocolw1" doxytag="SER_DATABITS_8"></a><em>SER_DATABITS_8</em></em>&nbsp;</td><td>
8 data bits </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="MbusSerialMasterProtocolw8" doxytag="MbusRtuMasterProtocol::@3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> anonymous enum<code> [inherited]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw8MbusSerialMasterProtocolw2" doxytag="SER_STOPBITS_1"></a><em>SER_STOPBITS_1</em></em>&nbsp;</td><td>
1 stop bit </td></tr>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw8MbusSerialMasterProtocolw3" doxytag="SER_STOPBITS_2"></a><em>SER_STOPBITS_2</em></em>&nbsp;</td><td>
2 stop bits </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="MbusSerialMasterProtocolw9" doxytag="MbusRtuMasterProtocol::@4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> anonymous enum<code> [inherited]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw9MbusSerialMasterProtocolw4" doxytag="SER_PARITY_NONE"></a><em>SER_PARITY_NONE</em></em>&nbsp;</td><td>
No parity. </td></tr>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw9MbusSerialMasterProtocolw5" doxytag="SER_PARITY_EVEN"></a><em>SER_PARITY_EVEN</em></em>&nbsp;</td><td>
Even parity. </td></tr>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolw9MbusSerialMasterProtocolw6" doxytag="SER_PARITY_ODD"></a><em>SER_PARITY_ODD</em></em>&nbsp;</td><td>
Odd parity. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="MbusSerialMasterProtocolx2" doxytag="MbusRtuMasterProtocol::@5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> anonymous enum<code> [protected, inherited]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolx2MbusSerialMasterProtocolx0" doxytag="SER_RS232"></a><em>SER_RS232</em></em>&nbsp;</td><td>
RS232 mode w/o RTS/CTS handshake. </td></tr>
<tr><td valign=top><em><a name="MbusSerialMasterProtocolx2MbusSerialMasterProtocolx1" doxytag="SER_RS485"></a><em>SER_RS485</em></em>&nbsp;</td><td>
RS485 mode: RTS enables/disables transmitter. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="MbusRtuMasterProtocolz3_0" doxytag="MbusRtuMasterProtocol::openProtocol"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int openProtocol </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *const&nbsp;</td>
          <td class="mdname" nowrap> <em>portName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>baudRate</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dataBits</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stopBits</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>parity</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Opens a Modbus RTU protocol and the associated serial port with specific port parameters. 
<p>
This function opens the serial port. After a port has been opened, data and control functions can be used.<p>
<dl compact><dt><b>Note:</b></dt><dd>The default time-out for the data transfer is 1000 ms. <p>
The default poll delay is 0 ms. <p>
Automatic retries are switched off (retry count is 0). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>portName</em>&nbsp;</td><td>Serial port identifier (e.g. "COM1", "/dev/ser1" or "/dev/ttyS0") </td></tr>
    <tr><td valign=top><em>baudRate</em>&nbsp;</td><td>The port baudRate in bps (typically 1200 - 9600). </td></tr>
    <tr><td valign=top><em>dataBits</em>&nbsp;</td><td>Must be SER_DATABITS_8 for RTU </td></tr>
    <tr><td valign=top><em>stopBits</em>&nbsp;</td><td>SER_STOPBITS_1: 1 stop bit, SER_STOPBITS_2: 2 stop bits </td></tr>
    <tr><td valign=top><em>parity</em>&nbsp;</td><td>SER_PARITY_NONE: no parity, SER_PARITY_ODD: odd parity, SER_PARITY_EVEN: even parity </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>

<p>
Reimplemented from <a class="el" href="a00012.html#MbusSerialMasterProtocolz25_0">MbusSerialMasterProtocol</a>.    </td>
  </tr>
</table>
<a name="MbusRtuMasterProtocolz3_1" doxytag="MbusRtuMasterProtocol::openProtocol"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int openProtocol </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *const&nbsp;</td>
          <td class="mdname" nowrap> <em>portName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>baudRate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Opens a Modbus RTU protocol and the associated serial port with default port parameters. 
<p>
This function opens the serial port with 8 databits, 1 stopbit and no parity. After a port has been opened, data and control functions can be used.<p>
<dl compact><dt><b>Note:</b></dt><dd>The default time-out for the data transfer is 1000 ms. <p>
The default poll delay is 0 ms. <p>
Automatic retries are switched off (retry count is 0). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>portName</em>&nbsp;</td><td>Serial port identifier (e.g. "COM1", "/dev/ser1" or "/dev/ttyS0") </td></tr>
    <tr><td valign=top><em>baudRate</em>&nbsp;</td><td>The port baudRate in bps (typically 1200 - 9600) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>

<p>
Reimplemented from <a class="el" href="a00012.html#MbusSerialMasterProtocolz25_1">MbusSerialMasterProtocol</a>.    </td>
  </tr>
</table>
<a name="MbusSerialMasterProtocolz25_3" doxytag="MbusRtuMasterProtocol::isOpen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int isOpen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether the protocol is open or not. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>true</em>&nbsp;</td><td>= open </td></tr>
    <tr><td valign=top><em>false</em>&nbsp;</td><td>= closed </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="a00009.html#MbusMasterFunctionsa1">MbusMasterFunctions</a>.    </td>
  </tr>
</table>
<a name="MbusSerialMasterProtocolz25_4" doxytag="MbusRtuMasterProtocol::enableRs485Mode"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int enableRs485Mode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rtsDelay</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enables RS485 mode. 
<p>
In RS485 mode the RTS signal can be used to enable and disable the transmitter of a RS232/RS485 converter. The RTS signal is asserted before sending data. It is cleared after the transmit buffer has been emptied and in addition the specified delay time has elapsed. The delay time is necessary because even the transmit buffer is already empty, the UART's FIFO will still contain unsent characters.<p>
<dl compact><dt><b>Warning:</b></dt><dd>The use of RTS controlled RS232/RS485 converters should be avoided if possible. It is difficult to determine the exact time when to switch off the transmitter with non real-time operating systems like Windows and Linux. If it is switched off to early characters might still sit in the FIFO or the transmit register of the UART and these characters will be lost. Hence the slave will not recognize the message. On the other hand if it is switched off too late then the slave's message is corrupted and the master will not recognize the message.</dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd>The delay value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rtsDelay</em>&nbsp;</td><td>Delay time in ms (Range: 0 - 100000) which applies after the transmit buffer is empty. 0 disables this mode. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<!-- <?php echo "--".">";
siteFooter();
echo "<"."!--"; if (false) { ?> -->
   <hr>
   <table width="100%" cellspacing=0 cellpadding=5 border=0>
      <tr>
         <td class=footer valign=top>
         Copyright &copy; 2002-2004 <a href="http://www.focus-sw.com">
         FOCUS Software Engineering Pty Ltd</a>, Australia.
         All rights reserved.
         <br>
         Please see the <a href="notices.html">Notices</a> page for trademark notices.
         <br>
         Last updated: 26 May 2004
     </tr>
   </table>

</body>
</html>
<!-- <?php } echo "--".">"; echo "<"."!--"; ?> -->

