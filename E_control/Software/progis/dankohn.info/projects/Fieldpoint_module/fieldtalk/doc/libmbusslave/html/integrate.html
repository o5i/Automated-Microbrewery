<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
   <TITLE>Modbus Slave C++ Library: How to integrate the Protocol in your Application</TITLE>
   <LINK href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
   <table width="100%"><tr>
   <td valign=bottom><b><font color=black size=4>
      FieldTalk<small><sup>&#153;</sup></small> Modbus<small><sup>&reg;</sup></small> Slave Library<br>
      C++ Editions</font></b></td>
   <td valign=bottom align=right>
      <a href="http://www.focus-sw.com">
      <img src="focuslogo50x200.png" border=0 size="50%"
       alt="FOCUS Software Engineering" ></a></td>
   </tr></table>
   <hr size=4 noshade color=gray>

<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="integrate">How to integrate the Protocol in your Application</a></h1><h2><a class="anchor" name="serialintegrate">
Using Serial Protocols</a></h2>
Let's assume we want to implement a Modbus slave device with slave address 1.<p>
The registers for reading are in the reference range 4:00100 to 4:00119 and the registers for writing are in the range 4:00200 to 4:00219. The discretes for reading are in the reference range 0:00010 to 0:00019 and the discretes for writing are in the range 0:00020 to 0:00029.<p>
1. Include the package header files <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "MbusRtuSlaveProtocol.hpp"</span>
</pre></div><p>
2. Device data profile definition<p>
Define the data sets which reflects the slave's data profile by type and size: <div class="fragment"><pre class="fragment"><span class="keywordtype">short</span> readRegSet[20];
<span class="keywordtype">short</span> writeRegSet[20];
<span class="keywordtype">char</span> readBitSet[10];
<span class="keywordtype">char</span> writeBitSet[10];
</pre></div><p>
3. Declare a Data Provider <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyDataProvider: <span class="keyword">public</span> <a class="code" href="classMbusDataTableInterface.html">MbusDataTableInterface</a>
{

  <span class="keyword">public</span>:

   <span class="keywordtype">int</span> readHoldingRegistersTable(<span class="keywordtype">int</span> startRef, <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for reading is at 100, so deduct offset</span>
      startRef -= 100;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(readRegSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(regArr, &amp;readRegSet[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                  <span class="keyword">const</span> <span class="keywordtype">short</span> regArr[],
                                  <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for writing is at 200, so deduct offset</span>
      startRef -= 200;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(writeRegSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(&amp;writeRegSet[startRef], regArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readCoilsTable(<span class="keywordtype">int</span> startRef,
                      <span class="keywordtype">char</span> bitArr[],
                      <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for reading is at 10, so deduct offset</span>
      startRef -= 10;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(readBitSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(bitArr, &amp;readBitSet[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeCoilsTable(<span class="keywordtype">int</span> startRef,
                       <span class="keyword">const</span> <span class="keywordtype">char</span> bitArr[],
                       <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for writing is at 20, so deduct offset</span>
      startRef -= 20;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(writeBitSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(&amp;writeBitSet[startRef], bitArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }

} dataProvider;
</pre></div><p>
4. Declare and instantiate a server object and associate it with the Data Provider <div class="fragment"><pre class="fragment"><a class="code" href="classMbusRtuSlaveProtocol.html">MbusRtuSlaveProtocol</a> mbusServer;
mbusServer.<a class="code" href="group__mbusslave.html#ga0">addDataTable</a>(1, &amp;dataProvider);
</pre></div><p>
5. Start-up the server <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> result;

   result = mbusServer.<a class="code" href="classMbusRtuSlaveProtocol.html#MbusRtuSlaveProtocola2">startupServer</a>(portName,
                                     9600L, <span class="comment">// Baudrate</span>
                                     8,     <span class="comment">// Databits</span>
                                     1,     <span class="comment">// Stopbits</span>
                                     0);    <span class="comment">// Parity</span>
   <span class="keywordflow">if</span> (result != FTALK_SUCCESS)
   {
      fprintf(stderr, <span class="stringliteral">"Error starting server: %s!\n"</span>,
              <a class="code" href="group__buserror.html#ga0">getBusProtocolErrorText</a>(result));
      exit(EXIT_FAILURE);
   }
</pre></div><p>
6. Execute cyclically the server loop <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> result = <a class="code" href="group__buserror.html#ga1">FTALK_SUCCESS</a>;

   <span class="keywordflow">while</span> (result == FTALK_SUCCESS)
   {
      result = mbusServer.<a class="code" href="classMbusRtuSlaveProtocol.html#MbusRtuSlaveProtocola4">serverLoop</a>();
      <span class="keywordflow">if</span> (result != FTALK_SUCCESS)
         fprintf(stderr, "%s!\n", getBusProtocolErrorText(result));
   }
</pre></div><p>
7. Shutdown the server if not needed any more <div class="fragment"><pre class="fragment">mbusServer.<a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolz27_4">shutdownServer</a>();
</pre></div><h2><a class="anchor" name="tcpintegrate">
Using MODBUS/TCP Protocol</a></h2>
Let's assume we want to implement a Modbus slave device with slave address 1.<p>
The registers for reading are in the reference range 4:00100 to 4:00119 and the registers for writing are in the range 4:00200 to 4:00219. The discretes for reading are in the reference range 0:00010 to 0:00019 and the discretes for writing are in the range 0:00020 to 0:00029.<p>
1. Include the package header files <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "MbusTcpSlaveProtocol.hpp"</span>
</pre></div><p>
2. Device data profile definition<p>
Define the data sets which reflects the slave's data profile by type and size: <div class="fragment"><pre class="fragment"><span class="keywordtype">short</span> readRegSet[20];
<span class="keywordtype">short</span> writeRegSet[20];
<span class="keywordtype">char</span> readBitSet[10];
<span class="keywordtype">char</span> writeBitSet[10];
</pre></div><p>
3. Declare a Data Provider <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyDataProvider: <span class="keyword">public</span> <a class="code" href="classMbusDataTableInterface.html">MbusDataTableInterface</a>
{

  <span class="keyword">public</span>:

   <span class="keywordtype">int</span> readHoldingRegistersTable(<span class="keywordtype">int</span> startRef, <span class="keywordtype">short</span> regArr[], <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for reading is at 100, so deduct offset</span>
      startRef -= 100;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(readRegSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(regArr, &amp;readRegSet[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeHoldingRegistersTable(<span class="keywordtype">int</span> startRef,
                                  <span class="keyword">const</span> <span class="keywordtype">short</span> regArr[],
                                  <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for writing is at 200, so deduct offset</span>
      startRef -= 200;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(writeRegSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(&amp;writeRegSet[startRef], regArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> readCoilsTable(<span class="keywordtype">int</span> startRef,
                      <span class="keywordtype">char</span> bitArr[],
                      <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for reading is at 10, so deduct offset</span>
      startRef -= 10;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(readBitSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(bitArr, &amp;readBitSet[startRef], refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }


   <span class="keywordtype">int</span> writeCoilsTable(<span class="keywordtype">int</span> startRef,
                       <span class="keyword">const</span> <span class="keywordtype">char</span> bitArr[],
                       <span class="keywordtype">int</span> refCnt)
   {
      <span class="comment">// Adjust Modbus reference counting</span>
      startRef--;

      <span class="comment">// Our start address for writing is at 20, so deduct offset</span>
      startRef -= 20;

      <span class="comment">// Validate range</span>
      <span class="keywordflow">if</span> (startRef + refCnt &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(writeBitSet) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
         <span class="keywordflow">return</span> (0);

      <span class="comment">// Copy data</span>
      memcpy(&amp;writeBitSet[startRef], bitArr, refCnt * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
      <span class="keywordflow">return</span> (1);
   }

} dataProvider;
</pre></div><p>
4. Declare and instantiate a server object and associate it with the Data Provider and the slave address. <div class="fragment"><pre class="fragment"><a class="code" href="classMbusTcpSlaveProtocol.html">MbusTcpSlaveProtocol</a> mbusServer();
mbusServer.<a class="code" href="group__mbusslave.html#ga0">addDataTable</a>(1, &amp;dataProvider);
</pre></div><p>
5. Change the default port from 502 to semething else if server shall not run as root. This step is not necessary when the server can run with root privilege. <div class="fragment"><pre class="fragment">   mbusServer.setPort(5000);
</pre></div><p>
6. Start-up the server <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> result;

   result = mbusServer.<a class="code" href="classMbusRtuSlaveProtocol.html#MbusRtuSlaveProtocola2">startupServer</a>();
   <span class="keywordflow">if</span> (result != FTALK_SUCCESS)
   {
      fprintf(stderr, <span class="stringliteral">"Error starting server: %s!\n"</span>,
              <a class="code" href="group__buserror.html#ga0">getBusProtocolErrorText</a>(result));
      exit(EXIT_FAILURE);
   }
</pre></div><p>
7. Execute cyclically the server loop <div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> result = <a class="code" href="group__buserror.html#ga1">FTALK_SUCCESS</a>;

   <span class="keywordflow">while</span> (result == FTALK_SUCCESS)
   {
      result = mbusServer.<a class="code" href="classMbusRtuSlaveProtocol.html#MbusRtuSlaveProtocola4">serverLoop</a>();
      <span class="keywordflow">if</span> (result != FTALK_SUCCESS)
         fprintf(stderr, "%s!\n", getBusProtocolErrorText(result));
   }
</pre></div><p>
8. Shutdown the server if not needed any more <div class="fragment"><pre class="fragment">mbusServer.<a class="code" href="classMbusSerialSlaveProtocol.html#MbusSerialSlaveProtocolz27_4">shutdownServer</a>();
</pre></div><h2><a class="anchor" name="examplesintegrate">
Examples</a></h2>
<ul>
<li><a class="el" href="examples.html#example1">A Tiny Slave</a></li><li><a class="el" href="examples.html#example2">Shared Memory Data Provider example</a></li><li><a class="el" href="examples.html#example3">Diagnostic Slave</a> </li></ul>
   <hr>
   <table width="100%" cellspacing=0 cellpadding=5 border=0>
      <tr>
         <td class=footer valign=top>
         Copyright &copy; 2002-2006 <a href="http://www.focus-sw.com">
         FOCUS Software Engineering Pty Ltd</a>, Australia.
         All rights reserved.
         <br>
         Please see the <a href="notices.html">Notices</a> page for trademark notices.
         <br>
         Last updated: 20 Oct 2006
     </tr>
   </table>

</body>
</html>

