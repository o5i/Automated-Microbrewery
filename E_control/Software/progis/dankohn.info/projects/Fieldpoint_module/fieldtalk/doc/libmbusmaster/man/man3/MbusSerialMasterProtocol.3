.TH "MbusSerialMasterProtocol" 3 "26 May 2004" "Modbus Protocol Library Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MbusSerialMasterProtocol \- 
.SH SYNOPSIS
.br
.PP
Inherits \fBMbusMasterFunctions\fP.
.PP
Inherited by \fBMbusAsciiMasterProtocol\fP, and \fBMbusRtuMasterProtocol\fP.
.PP
.SH "Detailed Description"
.PP 
Base class for serial serial master protocols. 

This base class realises the Modbus serial master protocols. It provides functions to open and to close serial port as well as data and control functions which can be used at any time after the protocol has been opened. The data and control functions are organized different conformance classes. For a more detailed description of the data and control functions see section \fBData and Control Functions for all Protocol Flavours\fP.
.PP
It is possible to instantiate multiple instances for establishing multiple connections on different serial ports (They should be executed in separate threads).
.PP
\fBVersion:\fP
.RS 4
1.1 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBmbusmaster\fP 
.PP
\fBMbusMasterFunctions\fP 
.RE
.PP

.PP
.SS "Serial Port Management Functions"

.in +1c
.ti -1c
.RI "virtual int \fBopenProtocol\fP (const char *const portName, long baudRate, int dataBits, int stopBits, int parity)"
.br
.RI "\fIOpens a serial Modbus protocol and the associated serial port with specific port parameters. \fP"
.ti -1c
.RI "virtual int \fBopenProtocol\fP (const char *const portName, long baudRate)"
.br
.RI "\fIOpens a serial Modbus protocol and the associated serial port with default port parameters. \fP"
.ti -1c
.RI "virtual void \fBcloseProtocol\fP ()"
.br
.RI "\fICloses the serial port and releases any system resources associated with the port. \fP"
.ti -1c
.RI "virtual int \fBisOpen\fP ()"
.br
.RI "\fIReturns whether the protocol is open or not. \fP"
.ti -1c
.RI "virtual int \fBenableRs485Mode\fP (int rtsDelay)"
.br
.RI "\fIEnables RS485 mode. \fP"
.in -1c
.SS "Class 0 Modbus Functions"

.in +1c
.ti -1c
.RI "int \fBwriteMultipleRegisters\fP (int slaveAddr, int startRef, const short regArr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 hex), Preset Multiple Registers/Write Multiple Registers. \fP"
.ti -1c
.RI "int \fBwriteMultipleLongInts\fP (int slaveAddr, int startRef, const long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. \fP"
.ti -1c
.RI "int \fBwriteMultipleMod10000\fP (int slaveAddr, int startRef, const long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. \fP"
.ti -1c
.RI "int \fBwriteMultipleFloats\fP (int slaveAddr, int startRef, const float float32Arr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. \fP"
.ti -1c
.RI "int \fBreadMultipleRegisters\fP (int slaveAddr, int startRef, short regArr[], int refCnt)"
.br
.RI "\fIModbus function 3 (03 hex), Read Holding Registers/Read Multiple Registers. \fP"
.ti -1c
.RI "int \fBreadMultipleLongInts\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 3 (03 hex) for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. \fP"
.ti -1c
.RI "int \fBreadMultipleMod10000\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 3 (03 hex) for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. \fP"
.ti -1c
.RI "int \fBreadMultipleFloats\fP (int slaveAddr, int startRef, float float32Arr[], int refCnt)"
.br
.RI "\fIModbus function 3 (03 hex) for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. \fP"
.in -1c
.SS "Class 1 Modbus Functions"

.in +1c
.ti -1c
.RI "int \fBreadCoils\fP (int slaveAddr, int startRef, int bitArr[], int refCnt)"
.br
.RI "\fIModbus function 1 (01 hex), Read Coil Status/Read Coils. \fP"
.ti -1c
.RI "int \fBreadInputDiscretes\fP (int slaveAddr, int startRef, int bitArr[], int refCnt)"
.br
.RI "\fIModbus function 2 (02 hex), Read Inputs Status/Read Input Discretes. \fP"
.ti -1c
.RI "int \fBreadInputRegisters\fP (int slaveAddr, int startRef, short regArr[], int refCnt)"
.br
.RI "\fIModbus function 4 (04 hex), Read Input Registers. \fP"
.ti -1c
.RI "int \fBreadInputLongInts\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 4 (04 hex) for 32-bit long int data types, Read Input Registers as long int data. \fP"
.ti -1c
.RI "int \fBreadInputMod10000\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 4 (04 hex) for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. \fP"
.ti -1c
.RI "int \fBreadInputFloats\fP (int slaveAddr, int startRef, float float32Arr[], int refCnt)"
.br
.RI "\fIModbus function 4 (04 hex) for 32-bit float data types, Read Input Registers as float data. \fP"
.ti -1c
.RI "int \fBwriteCoil\fP (int slaveAddr, int bitAddr, int bitVal)"
.br
.RI "\fIModbus function 5 (05 hex), Force Single Coil/Write Coil. \fP"
.ti -1c
.RI "int \fBwriteSingleRegister\fP (int slaveAddr, int regAddr, short regVal)"
.br
.RI "\fIModbus function 6 (06 hex), Preset Single Register/Write Single Register. \fP"
.ti -1c
.RI "int \fBreadExceptionStatus\fP (int slaveAddr, unsigned char *statusByte)"
.br
.RI "\fIModbus function 7 (07 hex), Read Exception Status. \fP"
.in -1c
.SS "Class 2 Modbus Functions"

.in +1c
.ti -1c
.RI "int \fBforceMultipleCoils\fP (int slaveAddr, int startRef, const int bitArr[], int refCnt)"
.br
.RI "\fIModbus function 15 (0F hex), Force Multiple Coils. \fP"
.ti -1c
.RI "int \fBmaskWriteRegister\fP (int slaveAddr, int regAddr, unsigned short andMask, unsigned short orMask)"
.br
.RI "\fIModbus function 22 (16 hex), Mask Write Register. \fP"
.ti -1c
.RI "int \fBreadWriteRegisters\fP (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)"
.br
.RI "\fIModbus function 23 (17 hex), Read/Write Registers. \fP"
.in -1c
.SS "Protocol Configuration"

.in +1c
.ti -1c
.RI "int \fBsetTimeout\fP (int timeOut)"
.br
.RI "\fIConfigures time-out. \fP"
.ti -1c
.RI "int \fBgetTimeout\fP ()"
.br
.RI "\fIReturns the time-out value. \fP"
.ti -1c
.RI "int \fBsetPollDelay\fP (int pollDelay)"
.br
.RI "\fIConfigures poll delay. \fP"
.ti -1c
.RI "int \fBgetPollDelay\fP ()"
.br
.RI "\fIReturns the poll delay time. \fP"
.ti -1c
.RI "int \fBsetRetryCnt\fP (int retryCnt)"
.br
.RI "\fIConfigures the automatic retry setting. \fP"
.ti -1c
.RI "int \fBgetRetryCnt\fP ()"
.br
.RI "\fIReturns the automatic retry count. \fP"
.in -1c
.SS "Transmission Statistic Functions"

.in +1c
.ti -1c
.RI "unsigned long \fBgetTotalCounter\fP ()"
.br
.RI "\fIReturns how often a message transfer has been executed. \fP"
.ti -1c
.RI "void \fBresetTotalCounter\fP ()"
.br
.RI "\fIResets total message transfer counter. \fP"
.ti -1c
.RI "unsigned long \fBgetSuccessCounter\fP ()"
.br
.RI "\fIReturns how often a message transfer was successful. \fP"
.ti -1c
.RI "void \fBresetSuccessCounter\fP ()"
.br
.RI "\fIResets successful message transfer counter. \fP"
.in -1c
.SS "Word Order Configuration"

.in +1c
.ti -1c
.RI "void \fBconfigureBigEndianInts\fP ()"
.br
.RI "\fIConfigures int data type functions to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureSwappedFloats\fP ()"
.br
.RI "\fIConfigures float data type functions to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureLittleEndianInts\fP ()"
.br
.RI "\fIConfigures int data type functions not to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureIeeeFloats\fP ()"
.br
.RI "\fIConfigures float data type functions not to do a word swap. \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum { \fBSER_DATABITS_7\fP =  SerialPort::SER_DATABITS_7, \fBSER_DATABITS_8\fP =  SerialPort::SER_DATABITS_8 }"
.br
.ti -1c
.RI "enum { \fBSER_STOPBITS_1\fP =  SerialPort::SER_STOPBITS_1, \fBSER_STOPBITS_2\fP =  SerialPort::SER_STOPBITS_2 }"
.br
.ti -1c
.RI "enum { \fBSER_PARITY_NONE\fP =  SerialPort::SER_PARITY_NONE, \fBSER_PARITY_EVEN\fP =  SerialPort::SER_PARITY_EVEN, \fBSER_PARITY_ODD\fP =  SerialPort::SER_PARITY_ODD }"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "char * \fBgetPackageVersion\fP ()"
.br
.RI "\fIReturns the package version number. \fP"
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum { \fBSER_RS232\fP, \fBSER_RS485\fP }"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBMbusSerialMasterProtocol\fP ()"
.br
.RI "\fIConstructs a MbusSerialMasterProtocol object and initialises its data. \fP"
.in -1c
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fISER_DATABITS_7\fP \fP\fP
7 data bits 
.TP
\fB\fI\fISER_DATABITS_8\fP \fP\fP
8 data bits 
.SS "anonymous enum"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fISER_STOPBITS_1\fP \fP\fP
1 stop bit 
.TP
\fB\fI\fISER_STOPBITS_2\fP \fP\fP
2 stop bits 
.SS "anonymous enum"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fISER_PARITY_NONE\fP \fP\fP
No parity. 
.TP
\fB\fI\fISER_PARITY_EVEN\fP \fP\fP
Even parity. 
.TP
\fB\fI\fISER_PARITY_ODD\fP \fP\fP
Odd parity. 
.SS "anonymous enum\fC [protected]\fP"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fISER_RS232\fP \fP\fP
RS232 mode w/o RTS/CTS handshake. 
.TP
\fB\fI\fISER_RS485\fP \fP\fP
RS485 mode: RTS enables/disables transmitter. 
.SH "Member Function Documentation"
.PP 
.SS "int openProtocol (const char *const portName, long baudRate, int dataBits, int stopBits, int parity)\fC [virtual]\fP"
.PP
Opens a serial Modbus protocol and the associated serial port with specific port parameters. This function opens the serial port. After a port has been opened, data and control functions can be used.
.PP
\fBNote:\fP
.RS 4
The default time-out for the data transfer is 1000 ms. 
.PP
The default poll delay is 0 ms. 
.PP
Automatic retries are switched off (retry count is 0). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIportName\fP Serial port identifier (e.g. 'COM1', '/dev/ser1' or '/dev/ttyS0') 
.br
\fIbaudRate\fP The port baudRate in bps (typically 1200 - 19200) 
.br
\fIdataBits\fP SER_DATABITS_7: 7 data bits (ASCII protocol only), SER_DATABITS_8: data bits 
.br
\fIstopBits\fP SER_STOPBITS_1: 1 stop bit, SER_STOPBITS_2: 2 stop bits 
.br
\fIparity\fP SER_PARITY_NONE: no parity, SER_PARITY_ODD: odd parity, SER_PARITY_EVEN: even parity 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP
Reimplemented in \fBMbusAsciiMasterProtocol\fP, and \fBMbusRtuMasterProtocol\fP.
.SS "int openProtocol (const char *const portName, long baudRate)\fC [virtual]\fP"
.PP
Opens a serial Modbus protocol and the associated serial port with default port parameters. This function opens the serial port with 8 databits, 1 stopbit and no parity. After a port has been opened, data and control functions can be used.
.PP
\fBNote:\fP
.RS 4
The default time-out for the data transfer is 1000 ms. 
.PP
The default poll delay is 0 ms. 
.PP
Automatic retries are switched off (retry count is 0). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIportName\fP Serial port identifier (e.g. 'COM1', '/dev/ser1' or '/dev/ttyS0') 
.br
\fIbaudRate\fP The port baudRate in bps (typically 1200 - 9600) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP
Reimplemented in \fBMbusAsciiMasterProtocol\fP, and \fBMbusRtuMasterProtocol\fP.
.SS "int isOpen ()\fC [virtual]\fP"
.PP
Returns whether the protocol is open or not. \fBReturn values:\fP
.RS 4
\fItrue\fP = open 
.br
\fIfalse\fP = closed 
.RE
.PP
Reimplemented from \fBMbusMasterFunctions\fP.
.SS "int enableRs485Mode (int rtsDelay)\fC [virtual]\fP"
.PP
Enables RS485 mode. In RS485 mode the RTS signal can be used to enable and disable the transmitter of a RS232/RS485 converter. The RTS signal is asserted before sending data. It is cleared after the transmit buffer has been emptied and in addition the specified delay time has elapsed. The delay time is necessary because even the transmit buffer is already empty, the UART's FIFO will still contain unsent characters.
.PP
\fBWarning:\fP
.RS 4
The use of RTS controlled RS232/RS485 converters should be avoided if possible. It is difficult to determine the exact time when to switch off the transmitter with non real-time operating systems like Windows and Linux. If it is switched off to early characters might still sit in the FIFO or the transmit register of the UART and these characters will be lost. Hence the slave will not recognize the message. On the other hand if it is switched off too late then the slave's message is corrupted and the master will not recognize the message.
.RE
.PP
\fBRemarks:\fP
.RS 4
The delay value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. 
.RE
.PP
\fBNote:\fP
.RS 4
A protocol must be closed in order to configure it. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIrtsDelay\fP Delay time in ms (Range: 0 - 100000) which applies after the transmit buffer is empty. 0 disables this mode. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_ARGUMENT_ERROR\fP Argument out of range 
.br
\fIFTALK_ILLEGAL_STATE_ERROR\fP Protocol is already open 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Modbus Protocol Library Documentation from the source code.
