.TH "MbusTcpSlaveProtocol" 3 "20 Oct 2006" "Modbus Slave C++ Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MbusTcpSlaveProtocol \- 
.SH SYNOPSIS
.br
.PP
Inherits \fBMbusSlaveServer\fP.
.PP
.SH "Detailed Description"
.PP 
MODBUS/TCP Slave Protocol class. 

This class realises the MODBUS/TCP slave protocol. It provides functions to start-up and to execute the server engine. This server engine can handle multiple master connections and is implemented as a single threaded TCP server. Upon receipt of a valid master query the server engine calls Data Provider methods to exchange data with the user application. For a more detailed description which Modbus data and control functions have been implemented in the server engine see section \fBServer Functions common to all Protocol Flavours\fP.
.PP
\fBSee also:\fP
.RS 4
\fBServer Functions common to all Protocol Flavours\fP, \fBMbusSlaveServer\fP 
.RE
.PP

.PP
.SS "MODBUS/TCP Server Management Functions"

.in +1c
.ti -1c
.RI "\fBMbusTcpSlaveProtocol\fP ()"
.br
.RI "\fIConstructs a MbusTcpSlaveProtocol object. \fP"
.ti -1c
.RI "\fBMbusTcpSlaveProtocol\fP (\fBMbusDataTableInterface\fP *dataTablePtr)"
.br
.RI "\fIConstructs a MbusTcpSlaveProtocol object data and associates it with a Data Provider. \fP"
.ti -1c
.RI "int \fBstartupServer\fP ()"
.br
.RI "\fIPuts the Modbus server into operation. \fP"
.ti -1c
.RI "int \fBstartupServer\fP (const char *const hostName)"
.br
.RI "\fIPuts the Modbus server into operation. \fP"
.ti -1c
.RI "int \fBstartupServer\fP (int slaveAddr)"
.br
.RI "\fIPuts the Modbus server into operation using a single slave address and data table. \fP"
.ti -1c
.RI "int \fBstartupServer\fP (int slaveAddr, const char *const hostName)"
.br
.RI "\fIPuts the Modbus server into operation using a single slave address and data table. \fP"
.ti -1c
.RI "void \fBshutdownServer\fP ()"
.br
.RI "\fIShuts down the Modbus server. \fP"
.ti -1c
.RI "int \fBserverLoop\fP ()"
.br
.RI "\fIMODBUS/TCP slave server loop. \fP"
.ti -1c
.RI "int \fBisStarted\fP ()"
.br
.RI "\fIReturns if server has been started up. \fP"
.ti -1c
.RI "int \fBgetConnectionStatus\fP ()"
.br
.RI "\fIChecks if a Modbus master is polling periodically. \fP"
.ti -1c
.RI "int \fBsetPort\fP (unsigned short portNo)"
.br
.RI "\fISets the TCP port number to be used by the protocol. \fP"
.ti -1c
.RI "void \fBinstallIpAddrValidationCallBack\fP (int(*f)(char *masterIpAddrSz))"
.br
.RI "\fIThis function installs a callback handler for validating a master's IP address. \fP"
.ti -1c
.RI "unsigned short \fBgetPort\fP ()"
.br
.RI "\fIReturns the TCP port number used by the protocol. \fP"
.in -1c
.SS "Server Management Functions"

.in +1c
.ti -1c
.RI "int \fBaddDataTable\fP (int slaveAddr, \fBMbusDataTableInterface\fP *dataTablePtr)"
.br
.RI "\fIAssociates a protocol object with a Data Provider and a slave address. \fP"
.in -1c
.SS "Protocol Configuration"

.in +1c
.ti -1c
.RI "long \fBsetTimeout\fP (long timeOut)"
.br
.RI "\fIConfigures master transmit time-out supervision. \fP"
.ti -1c
.RI "long \fBgetTimeout\fP ()"
.br
.RI "\fIReturns the master time-out supervision value. \fP"
.in -1c
.SS "Transmission Statistic Functions"

.in +1c
.ti -1c
.RI "unsigned long \fBgetTotalCounter\fP ()"
.br
.RI "\fIReturns how often a message transfer has been executed. \fP"
.ti -1c
.RI "void \fBresetTotalCounter\fP ()"
.br
.RI "\fIResets total message transfer counter. \fP"
.ti -1c
.RI "unsigned long \fBgetSuccessCounter\fP ()"
.br
.RI "\fIReturns how often a message transfer was successful. \fP"
.ti -1c
.RI "void \fBresetSuccessCounter\fP ()"
.br
.RI "\fIResets successful message transfer counter. \fP"
.in -1c
.SS "Utility Functions"

.in +1c
.ti -1c
.RI "static char * \fBgetPackageVersion\fP ()"
.br
.RI "\fIReturns the package version number. \fP"
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBMbusTcpSlaveProtocol\fP ()"
.PP
Constructs a MbusTcpSlaveProtocol object. 
.PP
The association with a Data Provider is done after construction using the addDataTable method. 
.SS "\fBMbusTcpSlaveProtocol\fP (\fBMbusDataTableInterface\fP * dataTablePtr)"
.PP
Constructs a MbusTcpSlaveProtocol object data and associates it with a Data Provider. 
.PP
Function is kept for compatibility with previous API versions, do not use for new implementations.
.PP
\fBParameters:\fP
.RS 4
\fIdataTablePtr\fP Modbus data table pointer. Must point to a Data Provider object derived from the \fBMbusDataTableInterface\fP class. The Data Provider is the interface between your application data and the Modbus network. 
.RE
.PP
.PP
\fBDeprecated\fP
.RS 4
This function is deprecated. The preferred way of assigning a dataTable is using the default constructor and configuring data table and slave address using addDataTable method. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "int startupServer ()"
.PP
Puts the Modbus server into operation. 
.PP
The server accepts connections on any interface.
.PP
This function opens a TCP/IP socket, binds the configured TCP port to the Modbus/TCP protocol and initialises the server engine.
.PP
\fBNote:\fP
.RS 4
If the configured TCP port is below IPPORT_RESERVED (usually 1024), the process has to run with root privilege! 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP

.SS "int startupServer (const char *const  hostName)"
.PP
Puts the Modbus server into operation. 
.PP
The server accepts connections only on the interfaces which match the supplied hostname or IP address. This method allows to run different servers on multiple interfaces (so called multihomed servers).
.PP
This function opens a TCP/IP socket, binds the configured TCP port to the Modbus/TCP protocol and initialises the server engine.
.PP
\fBNote:\fP
.RS 4
If the configured TCP port is below IPPORT_RESERVED (usually 1024), the process has to run with root privilege! 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhostName\fP String with IP address for a specific host interface or NULL if connections are accepted on any interface 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP

.SS "int startupServer (int slaveAddr)"
.PP
Puts the Modbus server into operation using a single slave address and data table. 
.PP
The server accepts connections on any interface.
.PP
Function is kept for compatibility with previous API versions, do not use for new implementations.
.PP
\fBNote:\fP
.RS 4
If the configured TCP port is below IPPORT_RESERVED (usually 1024), the process has to run with root privilege! 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus slave address for server to listen on (-1 - 255). 0 is regarded as a valid value for a MODBUS/TCP server address. A value of -1 means the server disregards the slave address and listens to all slave addresses. 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP
.PP
\fBDeprecated\fP
.RS 4
This function is deprecated. The preferred way of assigning a slave address is using the default constructor and configuring data table and slave address using addDataTable method. 
.RE
.PP

.SS "int startupServer (int slaveAddr, const char *const  hostName)"
.PP
Puts the Modbus server into operation using a single slave address and data table. 
.PP
Function is kept for compatibility with previous API versions, do not use for new implementations.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus slave address for server to listen on (-1 - 255). 0 is regarded as a valid value for a MODBUS/TCP server address. A value of -1 means the server disregards the slave address and listens to all slave addresses. 
.br
\fIhostName\fP String with IP address for a specific host interface or NULL if connections are accepted on any interface 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP
.PP
\fBDeprecated\fP
.RS 4
This function is deprecated. The preferred way of assigning a slave address is using the default constructor and configuring data table and slave address using addDataTable method. 
.RE
.PP

.SS "void shutdownServer ()\fC [virtual]\fP"
.PP
Shuts down the Modbus server. 
.PP
This function closes all TCP/IP connections to MODBUS/TCP masters and releases any system resources associated with the connections. 
.PP
Reimplemented from \fBMbusSlaveServer\fP.
.SS "int serverLoop ()\fC [virtual]\fP"
.PP
MODBUS/TCP slave server loop. 
.PP
This server loop must be called continuously. It must not be blocked. The server has to be started before calling the \fBserverLoop()\fP method. This server engine can handle multiple TCP/IP connections at the same time.
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBProtocol Errors and Exceptions\fP for a list of error codes. 
.RE
.PP

.PP
Implements \fBMbusSlaveServer\fP.
.SS "int isStarted ()\fC [virtual]\fP"
.PP
Returns if server has been started up. 
.PP
\fBReturn values:\fP
.RS 4
\fItrue\fP = started 
.br
\fIfalse\fP = shutdown 
.RE
.PP

.PP
Implements \fBMbusSlaveServer\fP.
.SS "int getConnectionStatus ()\fC [virtual]\fP"
.PP
Checks if a Modbus master is polling periodically. 
.PP
\fBReturn values:\fP
.RS 4
\fItrue\fP = A master is polling at a frequency higher than the master transmit time-out value 
.br
\fIfalse\fP = No master is polling within the time-out period 
.RE
.PP
\fBNote:\fP
.RS 4
The master transmit time-out value must be set > 0 in order for this function to work. 
.RE
.PP

.PP
Implements \fBMbusSlaveServer\fP.
.SS "int setPort (unsigned short portNo)"
.PP
Sets the TCP port number to be used by the protocol. 
.PP
\fBRemarks:\fP
.RS 4
Usually the port number remains unchanged and defaults to 502. In this case no call to this function is necessary. However if the port number has to be different from 502 this function must be called \fIbefore\fP starting the server with \fBstartupServer()\fP.
.RE
.PP
\fBNote:\fP
.RS 4
If the configured TCP port is below IPPORT_RESERVED (usually 1024), the process has to run with root privilege! 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIportNo\fP Port number the server shall listen on 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_STATE_ERROR\fP Server already running 
.RE
.PP

.SS "void installIpAddrValidationCallBack (int(*)(char *masterIpAddrSz) f)"
.PP
This function installs a callback handler for validating a master's IP address. 
.PP
Pass a pointer to a function with checks a master's IP address and either accepts or rejects a master's connection.
.PP
\fBParameters:\fP
.RS 4
\fImasterIpAddrSz\fP IPv4 Internet host address string in the standard numbers-and-dots notation.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns 1 to accept a connection or 0 to reject it. 
.RE
.PP

.SS "unsigned short getPort ()"
.PP
Returns the TCP port number used by the protocol. 
.PP
\fBReturns:\fP
.RS 4
Port number used by the protocol 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Modbus Slave C++ Library from the source code.
