<!-- <?php echo "--".">";
include_once $_SERVER['DOCUMENT_ROOT'] . '/include/prepend.inc';
siteHeader("Modbus Master Protocol Library / C++ Editions - MbusRtuOverTcpMasterProtocol class Reference",
           // Description:
           "Modbus RTU, Modbus ASCII, MODBUS/TCP Master C++ library and driver Documentation",
           // Keywords:
           $keywords);
echo "<"."!--"; if (false) { ?> -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
   <TITLE>FieldTalk Modbus Master Protocol Library / C++ Editions - MbusRtuOverTcpMasterProtocol class Reference</TITLE>
   <LINK href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
   <table width="100%"><tr>
   <td valign=bottom><b><font color=black size=4>
      FieldTalk<small><sup>&#153;</sup></small> Modbus<small><sup>&reg;</sup></small> Master Protocol Library<br>
      C++ Editions</font></b></td>
   <td valign=bottom align=right>
      <a href="http://www.focus-sw.com">
      <img src="focuslogo50x200.png" border=0 size="50%"
       alt="FOCUS Software Engineering" ></a></td>
   </tr></table>
   <hr size=4 noshade color=gray>
<!-- <?php } echo "--".">"; echo "<"."!--"; ?> -->

<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>MbusRtuOverTcpMasterProtocol Class Reference<br>
<small>
[<a class="el" href="a00040.html">Encapsulated Modbus RTU Protocol</a>]</small>
</h1>Inheritance diagram for MbusRtuOverTcpMasterProtocol:<p><center><img src="a00052.gif" border="0" usemap="#a00053" alt="Inheritance graph"></center>
<map name="a00053">
<area href="a00013.html" shape="rect" coords="31,432,199,640" alt="">
<area href="a00009.html" shape="rect" coords="33,16,196,384" alt="">
</map>
Collaboration diagram for MbusRtuOverTcpMasterProtocol:<p><center><img src="a00054.gif" border="0" usemap="#a00055" alt="Collaboration graph"></center>
<map name="a00055">
<area href="a00013.html" shape="rect" coords="31,432,199,640" alt="">
<area href="a00009.html" shape="rect" coords="33,16,196,384" alt="">
</map>
<a href="a00006.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Encapsulated Modbus RTU Master Protocol class. 
<p>
This class realises the Encapsulated Modbus RTU master protocol. This protocol is also known as RTU over TCP or RTU/IP and used for example by ISaGraf® Soft-PLCs. This class provides functions to establish and to close a TCP/IP connection to the slave as well as data and control functions which can be used after a connection to a slave device has been established successfully. The data and control functions are organized different conformance classes. For a more detailed description of the data and control functions see section <a class="el" href="a00036.html">Data and Control Functions for all Protocol Flavours</a>.<p>
It is also possible to instantiate multiple instances of this class for establishing multiple connections to either the same or different hosts.<p>
<dl compact><dt><b>Version:</b></dt><dd>1.0 </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="a00036.html">mbusmaster</a> <p>
<a class="el" href="a00009.html">MbusMasterFunctions</a> </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>TCP/IP Connection Management Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="MbusTcpMasterProtocolz21_1" doxytag="MbusRtuOverTcpMasterProtocol::closeProtocol"></a>
virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00011.html#MbusTcpMasterProtocolz21_1">closeProtocol</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a TCP/IP connection to a slave and releases any system resources associated with the connection. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00011.html#MbusTcpMasterProtocolz21_2">isOpen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether currently connected or not. </em> <a href="#MbusTcpMasterProtocolz21_2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned short&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00011.html#MbusTcpMasterProtocolz21_4">getPort</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the TCP port number used by the protocol. </em> <a href="#MbusTcpMasterProtocolz21_4"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 0 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a0">writeMultipleRegisters</a> (int slaveAddr, int startRef, const short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex), Preset Multiple Registers/Write Multiple Registers. </em> <a href="a00036.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a7">writeMultipleLongInts</a> (int slaveAddr, int startRef, const long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. </em> <a href="a00036.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a8">writeMultipleMod10000</a> (int slaveAddr, int startRef, const long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. </em> <a href="a00036.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a9">writeMultipleFloats</a> (int slaveAddr, int startRef, const float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. </em> <a href="a00036.html#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a10">readMultipleRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex), Read Holding Registers/Read Multiple Registers. </em> <a href="a00036.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a11">readMultipleLongInts</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. </em> <a href="a00036.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a12">readMultipleMod10000</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. </em> <a href="a00036.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a13">readMultipleFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. </em> <a href="a00036.html#a13"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 1 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a1">readCoils</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 1 (01 hex), Read Coil Status/Read Coils. </em> <a href="a00036.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a14">readInputDiscretes</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 2 (02 hex), Read Inputs Status/Read Input Discretes. </em> <a href="a00036.html#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a15">readInputRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex), Read Input Registers. </em> <a href="a00036.html#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a16">readInputLongInts</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit long int data types, Read Input Registers as long int data. </em> <a href="a00036.html#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a17">readInputMod10000</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. </em> <a href="a00036.html#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a18">readInputFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit float data types, Read Input Registers as float data. </em> <a href="a00036.html#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a19">writeCoil</a> (int slaveAddr, int bitAddr, int bitVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 5 (05 hex), Force Single Coil/Write Coil. </em> <a href="a00036.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a20">writeSingleRegister</a> (int slaveAddr, int regAddr, short regVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 6 (06 hex), Preset Single Register/Write Single Register. </em> <a href="a00036.html#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a21">readExceptionStatus</a> (int slaveAddr, unsigned char *statusByte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 7 (07 hex), Read Exception Status. </em> <a href="a00036.html#a21"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 2 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a2">forceMultipleCoils</a> (int slaveAddr, int startRef, const int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 15 (0F hex), Force Multiple Coils. </em> <a href="a00036.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a22">maskWriteRegister</a> (int slaveAddr, int regAddr, unsigned short andMask, unsigned short orMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 22 (16 hex), Mask Write Register. </em> <a href="a00036.html#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a23">readWriteRegisters</a> (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 23 (17 hex), Read/Write Registers. </em> <a href="a00036.html#a23"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Protocol Configuration</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a3">setTimeout</a> (int timeOut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures time-out. </em> <a href="a00036.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a24">getTimeout</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the time-out value. </em> <a href="a00036.html#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a25">setPollDelay</a> (int pollDelay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures poll delay. </em> <a href="a00036.html#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a26">getPollDelay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the poll delay time. </em> <a href="a00036.html#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a27">setRetryCnt</a> (int retryCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the automatic retry setting. </em> <a href="a00036.html#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a28">getRetryCnt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the automatic retry count. </em> <a href="a00036.html#a28"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Transmission Statistic Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a4">getTotalCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer has been executed. </em> <a href="a00036.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="MbusRtuOverTcpMasterProtocol::resetTotalCounter"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a29">resetTotalCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets total message transfer counter. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a30">getSuccessCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer was successful. </em> <a href="a00036.html#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a31" doxytag="MbusRtuOverTcpMasterProtocol::resetSuccessCounter"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a31">resetSuccessCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets successful message transfer counter. <br><br></td></tr>
<tr><td colspan=2><br><h2>Word Order Configuration</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a5">configureBigEndianInts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures int data type functions to do a word swap. </em> <a href="a00036.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a32">configureSwappedFloats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions to do a word swap. </em> <a href="a00036.html#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a33">configureLittleEndianInts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures int data type functions not to do a word swap. </em> <a href="a00036.html#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a34">configureIeeeFloats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions not to do a word swap. </em> <a href="a00036.html#a34"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="MbusRtuOverTcpMasterProtocola0" doxytag="MbusRtuOverTcpMasterProtocol::MbusRtuOverTcpMasterProtocol"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00011.html#MbusRtuOverTcpMasterProtocola0">MbusRtuOverTcpMasterProtocol</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a MbusRtuOverTcpMasterProtocol object and initialises its data. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00011.html#MbusRtuOverTcpMasterProtocola1">openProtocol</a> (const char *const hostName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects to a Encapsulated Modbus RTU slave. </em> <a href="#MbusRtuOverTcpMasterProtocola1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00011.html#MbusRtuOverTcpMasterProtocola2">setPort</a> (unsigned short portNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP port number to be used by the protocol. </em> <a href="#MbusRtuOverTcpMasterProtocola2"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a6">getPackageVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the package version number. </em> <a href="a00036.html#a6"></a><em><br><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="MbusRtuOverTcpMasterProtocola1" doxytag="MbusRtuOverTcpMasterProtocol::openProtocol"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int openProtocol </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>hostName</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connects to a Encapsulated Modbus RTU slave. 
<p>
This function establishes a logical network connection between master and slave. After a connection has been established data and control functions can be used. A TCP/IP connection should be closed if it is no longer needed.<p>
<dl compact><dt><b>Note:</b></dt><dd>The default time-out for the connection is 1000 ms. <p>
The default TCP port number is 1100. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>hostName</em>&nbsp;</td><td>String with IP address or host name </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>

<p>
Reimplemented from <a class="el" href="a00013.html#MbusTcpMasterProtocolz21_0">MbusTcpMasterProtocol</a>.    </td>
  </tr>
</table>
<a name="MbusRtuOverTcpMasterProtocola2" doxytag="MbusRtuOverTcpMasterProtocol::setPort"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int setPort </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>portNo</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the TCP port number to be used by the protocol. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Usually the port number remains unchanged and defaults to 1100. In this case no call to this function is necessary. However if the port number has to be different from 1100 this function must be called <em>before</em> opening the connection with <a class="el" href="a00011.html#MbusRtuOverTcpMasterProtocola1">openProtocol()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>portNo</em>&nbsp;</td><td>Port number to be used when opening the connection </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol already open </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="a00013.html#MbusTcpMasterProtocolz21_3">MbusTcpMasterProtocol</a>.    </td>
  </tr>
</table>
<a name="MbusTcpMasterProtocolz21_2" doxytag="MbusRtuOverTcpMasterProtocol::isOpen"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int isOpen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether currently connected or not. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>true</em>&nbsp;</td><td>= connected </td></tr>
    <tr><td valign=top><em>false</em>&nbsp;</td><td>= not connected </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="a00009.html#MbusMasterFunctionsa1">MbusMasterFunctions</a>.    </td>
  </tr>
</table>
<a name="MbusTcpMasterProtocolz21_4" doxytag="MbusRtuOverTcpMasterProtocol::getPort"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned short getPort </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the TCP port number used by the protocol. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Port number used by the protocol </dd></dl>
    </td>
  </tr>
</table>
<!-- <?php echo "--".">";
siteFooter();
echo "<"."!--"; if (false) { ?> -->
   <hr>
   <table width="100%" cellspacing=0 cellpadding=5 border=0>
      <tr>
         <td class=footer valign=top>
         Copyright &copy; 2002-2004 <a href="http://www.focus-sw.com">
         FOCUS Software Engineering Pty Ltd</a>, Australia.
         All rights reserved.
         <br>
         Please see the <a href="notices.html">Notices</a> page for trademark notices.
         <br>
         Last updated: 26 May 2004
     </tr>
   </table>

</body>
</html>
<!-- <?php } echo "--".">"; echo "<"."!--"; ?> -->

