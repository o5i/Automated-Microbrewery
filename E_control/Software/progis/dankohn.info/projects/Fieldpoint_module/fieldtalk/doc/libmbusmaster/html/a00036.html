<!-- <?php echo "--".">";
include_once $_SERVER['DOCUMENT_ROOT'] . '/include/prepend.inc';
siteHeader("Modbus Master Protocol Library / C++ Editions - Data and Control Functions for all Protocol Flavours",
           // Description:
           "Modbus RTU, Modbus ASCII, MODBUS/TCP Master C++ library and driver Documentation",
           // Keywords:
           $keywords);
echo "<"."!--"; if (false) { ?> -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
   <TITLE>FieldTalk Modbus Master Protocol Library / C++ Editions - Data and Control Functions for all Protocol Flavours</TITLE>
   <LINK href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
   <table width="100%"><tr>
   <td valign=bottom><b><font color=black size=4>
      FieldTalk<small><sup>&#153;</sup></small> Modbus<small><sup>&reg;</sup></small> Master Protocol Library<br>
      C++ Editions</font></b></td>
   <td valign=bottom align=right>
      <a href="http://www.focus-sw.com">
      <img src="focuslogo50x200.png" border=0 size="50%"
       alt="FOCUS Software Engineering" ></a></td>
   </tr></table>
   <hr size=4 noshade color=gray>
<!-- <?php } echo "--".">"; echo "<"."!--"; ?> -->

<!-- Generated by Doxygen 1.3.3 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Data and Control Functions for all Protocol Flavours</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This protocol stack implements the most commonly used Modbus data functions as well as some control functions. The functions to perform PLC program download and other device specific functions are outside the scope of this library. 
<p>
All functions of conformance Class 0 and Class 1 have been implemented. In addition the most frequent used functions of conformance Class 2 have been implemented. This rich function set enables a user to solve nearly every Modbus data transfer problem.<p>
The following table lists the available <em>FieldTalk Master Protocol Pack</em> functions:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Function Code</b></td><td><b>Current Terminology</b> </td><td><b>Classic Terminology</b> </td></tr>
<tr>
<td><b>Conformance Class 0</b> </td></tr>
<tr>
<td>3 (03 hex)</td><td>Read Multiple Registers </td><td>Read Holding Registers </td></tr>
<tr>
<td>16 (10 hex)</td><td>Write Multiple Registers </td><td>Preset Multiple Registers </td></tr>
<tr>
<td><b>Conformance Class 1</b> </td></tr>
<tr>
<td>1 (01 hex)</td><td>Read Coils</td><td>Read Coil Status </td></tr>
<tr>
<td>2 (02 hex)</td><td>Read Inputs Discretes </td><td>Read Input Status </td></tr>
<tr>
<td>4 (04 hex)</td><td>Read Input Registers </td><td>Read Input Registers </td></tr>
<tr>
<td>5 (05 hex)</td><td>Write Coil</td><td>Force Single Coil </td></tr>
<tr>
<td>6 (06 hex)</td><td>Write Single Register </td><td>Preset Single Register </td></tr>
<tr>
<td>7 (07 hex)</td><td>Read Exception Status </td><td>Read Exception Status </td></tr>
<tr>
<td><b>Conformance Class 2</b> </td></tr>
<tr>
<td>15 (0F hex)</td><td>Force Multiple Coils </td><td>Force Multiple Coils </td></tr>
<tr>
<td>22 (16 hex)</td><td>Mask Write Register </td><td>Mask Write Register </td></tr>
<tr>
<td>23 (17 hex)</td><td>Read/Write Registers </td><td>Read/Write Registers </td></tr>
</table>
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>When passing register numbers and discrete numbers to <em>FieldTalk </em> functions you have to use the the Modbus register and discrete numbering scheme. See <a class="el" href="modbus.html#mbusregnumbers">Register and Discrete Numbering Scheme</a>. (Internally the functions will deduct 1 from the start register value before transmitting the value to the slave device.)<p>
Most slave devices are limiting the amount of registers to be exchanged with the ASCII protocol to be 62 registers or 496 discretes. The limitation is based on the fact that the buffer must not exceed 256 bytes. </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Class 0 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a0">MbusMasterFunctions::writeMultipleRegisters</a> (int slaveAddr, int startRef, const short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex), Preset Multiple Registers/Write Multiple Registers. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a7">MbusMasterFunctions::writeMultipleLongInts</a> (int slaveAddr, int startRef, const long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a8">MbusMasterFunctions::writeMultipleMod10000</a> (int slaveAddr, int startRef, const long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a9">MbusMasterFunctions::writeMultipleFloats</a> (int slaveAddr, int startRef, const float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a10">MbusMasterFunctions::readMultipleRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex), Read Holding Registers/Read Multiple Registers. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a11">MbusMasterFunctions::readMultipleLongInts</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a12">MbusMasterFunctions::readMultipleMod10000</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a13">MbusMasterFunctions::readMultipleFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 (03 hex) for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 1 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a1">MbusMasterFunctions::readCoils</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 1 (01 hex), Read Coil Status/Read Coils. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a14">MbusMasterFunctions::readInputDiscretes</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 2 (02 hex), Read Inputs Status/Read Input Discretes. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a15">MbusMasterFunctions::readInputRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex), Read Input Registers. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a16">MbusMasterFunctions::readInputLongInts</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit long int data types, Read Input Registers as long int data. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a17">MbusMasterFunctions::readInputMod10000</a> (int slaveAddr, int startRef, long int32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a18">MbusMasterFunctions::readInputFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 (04 hex) for 32-bit float data types, Read Input Registers as float data. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a19">MbusMasterFunctions::writeCoil</a> (int slaveAddr, int bitAddr, int bitVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 5 (05 hex), Force Single Coil/Write Coil. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a20">MbusMasterFunctions::writeSingleRegister</a> (int slaveAddr, int regAddr, short regVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 6 (06 hex), Preset Single Register/Write Single Register. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a21">MbusMasterFunctions::readExceptionStatus</a> (int slaveAddr, unsigned char *statusByte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 7 (07 hex), Read Exception Status. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Class 2 Modbus Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a2">MbusMasterFunctions::forceMultipleCoils</a> (int slaveAddr, int startRef, const int bitArr[], int refCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 15 (0F hex), Force Multiple Coils. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a22">MbusMasterFunctions::maskWriteRegister</a> (int slaveAddr, int regAddr, unsigned short andMask, unsigned short orMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 22 (16 hex), Mask Write Register. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a23">MbusMasterFunctions::readWriteRegisters</a> (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 23 (17 hex), Read/Write Registers. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Protocol Configuration</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a3">MbusMasterFunctions::setTimeout</a> (int timeOut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures time-out. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a24">MbusMasterFunctions::getTimeout</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the time-out value. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a25">MbusMasterFunctions::setPollDelay</a> (int pollDelay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures poll delay. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a26">MbusMasterFunctions::getPollDelay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the poll delay time. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a27">MbusMasterFunctions::setRetryCnt</a> (int retryCnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the automatic retry setting. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a28">MbusMasterFunctions::getRetryCnt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the automatic retry count. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Transmission Statistic Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a4">MbusMasterFunctions::getTotalCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer has been executed. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="mbusmaster::resetTotalCounter"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a29">MbusMasterFunctions::resetTotalCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets total message transfer counter. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a30">MbusMasterFunctions::getSuccessCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer was successful. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a31" doxytag="mbusmaster::resetSuccessCounter"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a31">MbusMasterFunctions::resetSuccessCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets successful message transfer counter. <br><br></td></tr>
<tr><td colspan=2><br><h2>Word Order Configuration</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a5">MbusMasterFunctions::configureBigEndianInts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures int data type functions to do a word swap. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a32">MbusMasterFunctions::configureSwappedFloats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions to do a word swap. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a33">MbusMasterFunctions::configureLittleEndianInts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures int data type functions not to do a word swap. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a34">MbusMasterFunctions::configureIeeeFloats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions not to do a word swap. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00036.html#a6">MbusMasterFunctions::getPackageVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the package version number. </em> <a href="#a6"></a><em><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a0" doxytag="MbusMasterFunctions::writeMultipleRegisters"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int writeMultipleRegisters </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const short&nbsp;</td>
          <td class="mdname" nowrap> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 16 (10 hex), Preset Multiple Registers/Write Multiple Registers. 
<p>
Writes values into a sequence of output registers (holding registers, 4:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>regArr</em>&nbsp;</td><td>Buffer with the data to be sent. </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of references to be written (Range: 1-100) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="MbusMasterFunctions::readCoils"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readCoils </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 1 (01 hex), Read Coil Status/Read Coils. 
<p>
Reads the contents of the discrete outputs (coils, 0:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>bitArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of references to be read (Range: 1-2000) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="MbusMasterFunctions::forceMultipleCoils"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int forceMultipleCoils </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 15 (0F hex), Force Multiple Coils. 
<p>
Writes binary values into a sequence of discrete outputs (coils, 0:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>bitArr</em>&nbsp;</td><td>Buffer which contains the data to be sent </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of references to be written (Range: 1-800) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="MbusMasterFunctions::setTimeout"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int setTimeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msTime</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures time-out. 
<p>
This function sets the operation or socket time-out to the specified value.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The time-out value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>msTime</em>&nbsp;</td><td>Timeout value in ms (Range: 1 - 100000) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="MbusMasterFunctions::getTotalCounter"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long getTotalCounter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns how often a message transfer has been executed. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Counter value </dd></dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="MbusMasterFunctions::configureBigEndianInts"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void configureBigEndianInts </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures int data type functions to do a word swap. 
<p>
Modbus is using little-endian word order for 32-bit values. The data transfer functions operating upon 32-bit int data types can be configured to do a word swap which enables them to read 32-bit data correctly from a big-endian slave.     </td>
  </tr>
</table>
<a name="a6" doxytag="MbusMasterFunctions::getPackageVersion"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char * getPackageVersion </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the package version number. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Package version string </dd></dl>
    </td>
  </tr>
</table>
<a name="a7" doxytag="MbusMasterFunctions::writeMultipleLongInts"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int writeMultipleLongInts </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const long&nbsp;</td>
          <td class="mdname" nowrap> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 16 (10 hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. 
<p>
Writes long int values into pairs of output registers (holding registers, 4:00000 table).<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a long int value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of int values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>int32Arr</em>&nbsp;</td><td>Buffer with the data to be sent </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of long integers to be sent (Range: 1-50) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="MbusMasterFunctions::writeMultipleMod10000"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int writeMultipleMod10000 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const long&nbsp;</td>
          <td class="mdname" nowrap> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 16 (10 hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. 
<p>
Writes long int values into pairs of output registers (holding registers, 4:00000 table) representing a modulo-10000 long int value and performs number format conversion.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a modulo-10000 value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of int values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>int32Arr</em>&nbsp;</td><td>Buffer with the data to be sent </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of long integer values to be sent (Range: 1-50) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="MbusMasterFunctions::writeMultipleFloats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int writeMultipleFloats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const float&nbsp;</td>
          <td class="mdname" nowrap> <em>float32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 16 (10 hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. 
<p>
Writes float values into pairs of output registers (holding registers, 4:00000 table).<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a float value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of float values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>float32Arr</em>&nbsp;</td><td>Buffer with the data to be sent </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of float values to be sent (Range: 1-50) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="MbusMasterFunctions::readMultipleRegisters"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readMultipleRegisters </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>short&nbsp;</td>
          <td class="mdname" nowrap> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 3 (03 hex), Read Holding Registers/Read Multiple Registers. 
<p>
Reads the contents of the output registers (holding registers, 4:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>regArr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of registers to be read (Range: 1-125) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a11" doxytag="MbusMasterFunctions::readMultipleLongInts"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readMultipleLongInts </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 3 (03 hex) for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. 
<p>
Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) into 32-bit long int values.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a long int value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of int values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of long integers to be read (Range: 1-62) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="MbusMasterFunctions::readMultipleMod10000"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readMultipleMod10000 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 3 (03 hex) for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. 
<p>
Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) representing a modulo-10000 long int value into 32-bit int values and performs number format conversion.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a modulo-10000 value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of int values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of M10K integers to be read (Range: 1-62) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="MbusMasterFunctions::readMultipleFloats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readMultipleFloats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>float32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 3 (03 hex) for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. 
<p>
Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) into float values.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a float value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of float values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>float32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of float values to be read (Range: 1-62) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a14" doxytag="MbusMasterFunctions::readInputDiscretes"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readInputDiscretes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 2 (02 hex), Read Inputs Status/Read Input Discretes. 
<p>
Reads the contents of the discrete inputs (input status, 1:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>bitArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of references to be read (Range: 1-2000) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="MbusMasterFunctions::readInputRegisters"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readInputRegisters </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>short&nbsp;</td>
          <td class="mdname" nowrap> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 4 (04 hex), Read Input Registers. 
<p>
Read the contents of the input registers (3:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>regArr</em>&nbsp;</td><td>Buffer which will be filled with the data read. </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of references to be read (Range: 1-125) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="MbusMasterFunctions::readInputLongInts"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readInputLongInts </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 4 (04 hex) for 32-bit long int data types, Read Input Registers as long int data. 
<p>
Reads the contents of pairs of consecutive input registers (3:00000 table) into 32-bit long int values.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a long int value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of int values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of long integers to be read (Range: 1-62) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="MbusMasterFunctions::readInputMod10000"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readInputMod10000 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 4 (04 hex) for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. 
<p>
Reads the contents of pairs of consecutive input registers (3:00000 table) representing a modulo-10000 long int value into 32-bit long int values and performs number format conversion.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because an modulo-10000 value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of int values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of M10K integers to be read (Range: 1-62) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a18" doxytag="MbusMasterFunctions::readInputFloats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readInputFloats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>float32Arr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 4 (04 hex) for 32-bit float data types, Read Input Registers as float data. 
<p>
Reads the contents of pairs of consecutive input registers (3:00000 table) into float values.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Modbus does not know about any other data type than discretes and 16-bit registers. Because a float value is of 32-bit length, it will be transferred as two consecutive 16-bit registers. This means that the amount of registers transferred with this function is twice the amount of float values passed to this function. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>float32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign=top><em>refCnt</em>&nbsp;</td><td>Number of floats to be read (Range: 1-62) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="MbusMasterFunctions::writeCoil"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int writeCoil </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bitAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bitVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 5 (05 hex), Force Single Coil/Write Coil. 
<p>
Sets a single discrete output variable (coil, 0:00000 table) to either ON or OFF.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign=top><em>bitAddr</em>&nbsp;</td><td>Coil address (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>bitVal</em>&nbsp;</td><td>true sets, false clears discrete output variable </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="MbusMasterFunctions::writeSingleRegister"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int writeSingleRegister </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>regAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>short&nbsp;</td>
          <td class="mdname" nowrap> <em>regVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 6 (06 hex), Preset Single Register/Write Single Register. 
<p>
Writes a value into a single output register (holding register, 4:00000 reference).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign=top><em>regAddr</em>&nbsp;</td><td>Register address (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>regVal</em>&nbsp;</td><td>Data to be sent </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="MbusMasterFunctions::readExceptionStatus"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readExceptionStatus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned char *&nbsp;</td>
          <td class="mdname" nowrap> <em>statusByte</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 7 (07 hex), Read Exception Status. 
<p>
Reads the eight exception status coils within the slave device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>statusByte</em>&nbsp;</td><td>Slave status byte. The meaning of this status byte is slave specific and varies from device to device. identifier (Range: 1 - 255) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="MbusMasterFunctions::maskWriteRegister"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int maskWriteRegister </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>regAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>andMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned short&nbsp;</td>
          <td class="mdname" nowrap> <em>orMask</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 22 (16 hex), Mask Write Register. 
<p>
Masks bits according to an AND &amp; an OR mask into a single output register (holding register, 4:00000 reference). Masking is done as follows: result = (currentVal AND andMask) OR (orMask AND andMask)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>regAddr</em>&nbsp;</td><td>Register address (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>andMask</em>&nbsp;</td><td>Mask to be applied as a logic AND to the register </td></tr>
    <tr><td valign=top><em>orMask</em>&nbsp;</td><td>Mask to be applied as a logic OR to the register </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="MbusMasterFunctions::readWriteRegisters"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int readWriteRegisters </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>readRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>short&nbsp;</td>
          <td class="mdname" nowrap> <em>readArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>readCnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>writeRef</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const short&nbsp;</td>
          <td class="mdname" nowrap> <em>writeArr</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>writeCnt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus function 23 (17 hex), Read/Write Registers. 
<p>
Combines reading and writing of the output registers in one transaction (holding registers, 4:00000 table).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign=top><em>readRef</em>&nbsp;</td><td>Start reference for reading (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>readArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign=top><em>readCnt</em>&nbsp;</td><td>Number of registers to be read (Range: 1-125) </td></tr>
    <tr><td valign=top><em>writeRef</em>&nbsp;</td><td>Start reference for writing (Range: 1 - 0x10000) </td></tr>
    <tr><td valign=top><em>writeArr</em>&nbsp;</td><td>Buffer with data to be sent </td></tr>
    <tr><td valign=top><em>writeCnt</em>&nbsp;</td><td>Number of registers to be sent (Range: 1-100) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="a00041.html">Protocol Errors and Exceptions</a> for a list of error codes. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="MbusMasterFunctions::getTimeout"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int getTimeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the time-out value. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The time-out value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>Timeout value in ms </dd></dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="MbusMasterFunctions::setPollDelay"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int setPollDelay </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msTime</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures poll delay. 
<p>
This function sets the delay time which applies between two consecutive Modbus read/write. A value of 0 disables the poll delay.<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The delay value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>msTime</em>&nbsp;</td><td>Delay time in ms (Range: 0 - 100000), 0 disables poll delay </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="MbusMasterFunctions::getPollDelay"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int getPollDelay </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the poll delay time. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Delay time in ms, 0 if poll delay is switched off </dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="MbusMasterFunctions::setRetryCnt"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int setRetryCnt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>retries</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures the automatic retry setting. 
<p>
A value of 0 disables any automatic retries. <dl compact><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>retries</em>&nbsp;</td><td>Retry count (Range: 0 - 10), 0 disables retries </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign=top><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="MbusMasterFunctions::getRetryCnt"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int getRetryCnt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the automatic retry count. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Retry count </dd></dl>
    </td>
  </tr>
</table>
<a name="a30" doxytag="MbusMasterFunctions::getSuccessCounter"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long getSuccessCounter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns how often a message transfer was successful. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Counter value </dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="MbusMasterFunctions::configureSwappedFloats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void configureSwappedFloats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures float data type functions to do a word swap. 
<p>
The data functions operating upon 32-bit float data types can be configured to do a word swap. <dl compact><dt><b>Note:</b></dt><dd>Most platforms store floats in IEEE 754 little-endian order which does not need a word swap. </dd></dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="MbusMasterFunctions::configureLittleEndianInts"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void configureLittleEndianInts </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures int data type functions not to do a word swap. 
<p>
This is the default.     </td>
  </tr>
</table>
<a name="a34" doxytag="MbusMasterFunctions::configureIeeeFloats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void configureIeeeFloats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configures float data type functions not to do a word swap. 
<p>
This is the default.     </td>
  </tr>
</table>
<!-- <?php echo "--".">";
siteFooter();
echo "<"."!--"; if (false) { ?> -->
   <hr>
   <table width="100%" cellspacing=0 cellpadding=5 border=0>
      <tr>
         <td class=footer valign=top>
         Copyright &copy; 2002-2004 <a href="http://www.focus-sw.com">
         FOCUS Software Engineering Pty Ltd</a>, Australia.
         All rights reserved.
         <br>
         Please see the <a href="notices.html">Notices</a> page for trademark notices.
         <br>
         Last updated: 26 May 2004
     </tr>
   </table>

</body>
</html>
<!-- <?php } echo "--".">"; echo "<"."!--"; ?> -->

